/* Tool to automatically gather and analyze chat and replay communications.

aRt)Y Â© 2013 ProjectDRMF@gmail.com

Started: 28.07.2013
New algho: 19.01.2014
Last Edit: 23.07.2014

Gui 99 login/submit
1 go
2 goall
8 update
*/

try {
	if not A_IsAdmin
	{
		Run *RunAs "%A_ScriptFullPath%"
		ExitApp
	}
} catch e 
{
	ExitApp
}

#SingleInstance, OFF
#Warn All, Off
#MaxThreadsPerHotkey 3
#MaxThreads 2
#NoEnv
#MaxMem 100
SetTitleMatchMode,2

version = 1.4.2
name = PRISM v%version%
login_name = PRISM LOGIN
settingspath = %A_WorkingDir%\PRISM Settings.ini
WB_counter := 2
test := 10

IfWinExist,%login_name%
	WinClose, %login_name%

IfWinExist,%name%
	WinClose, %name%

Gosub, trayMenu

IfNotExist, %settingspath%
{
	MsgBox,64,%name% - %version%,
(
Hello,
a settings.ini has been created here (%settingspath%).

Please edit the file to suit your needs. If you need help, open the links in the settings.

Warnings: 
- Do NOT manually edit the following two options: L_Username and L_Password
- The tool might interfere with the Game Announcer
- Might not work for public/rarely played maps. For a list of supported maps, check the online readme

Please restart the tool after editing the settings.
)

	GoSub, iniwrite
	;Gosub, update
	uc := 1
	Run %settingspath%
	ExitApp
}

IniRead()

If (VersionCheck > version)
{
	MsgBox,16,Info,You are using an unknown version of the %name%.`nPlease wait until the settings.ini has been recreated/overwritten!`n%settingspath%`n`nPress Ok and restart the %name%.
	GoSub, iniwrite
	ExitApp
}

uc := 0

If (VersionCheck != version && (version > VersionCheck || VersionCheck = "ERROR"))
{

	MsgBox,64,%name% - New Version %version%,
(
Updating from v%VersionCheck% to v%version%

Some games might not be recorded/use different server links.
)	
GoSub, install
	IniRead()
}

Login:
{
;GoSub, trayMenu
Gui, 3: Destroy
Gui, 99: Destroy
Gui, 99: default
Gui, 99: +ToolWindow +AlwaysOnTop
Gui, 99: font, s12
Gui, 99: Add, text,y5 x5, Login Status:
Gui, 99: font, s12
Gui, 99: Add, text,y5 x103 w150 h25,Ready
	Gui, 99: font, s11 normal
	Gui, 99: Add, text,x5, Username:
	Gui, 99: Add, Edit,x80 yp-5 w160 h25 vL_U,
	Gui, 99: Add, text,x5, Password:
	Gui, 99: Add, Edit,x80 yp-5 w160 h25 password vL_P,
		Gui, 99: font, s10
		Gui, 99: Add, checkbox,x110 y90 h25 w150 vL_O,Save Login Data
		If (L_O = 1)
		{
			GuiControl, 99:, Button1, 1
			L_U := Crypt.Encrypt.StrDecrypt(L_U,"007",5,1)
			L_P := Crypt.Encrypt.StrDecrypt(L_P,"007",5,1)

			GuiControl, 99:, Edit1,%L_U%
			GuiControl, 99:, Edit2,%L_P%
		}
Gui, 99: font, s11 normal
Gui, 99: Add, button, x5 y100 h25 w100 gSubmitInfo +default, Log me in
Gui, 99: add, checkbox,x110 y110 h25 w150 vAutoLogin,Auto-Login
		If (AutoLogin = 1)
			GuiControl, 99:, Button3, 1
			
GuiControl, 99: Disable, Button2
Gui, 99: Show, h135 w250,%login_name%
GoSub, Icons
	IfExist,%A_workingdir%\logo.ico
		Menu, Tray, icon, %A_workingdir%\logo.ico
			DllCall("uxtheme\SetWindowThemeAttribute", "ptr", WinExist(), "int", 1, "int64*", 6 | 6<<32, "uint", 8)


	If (IEerror = 0)
	{
	Gui, 99: font, s12 cBlue bold
		GuiControl, 99: font, Static2	
	GuiControl, 99:,Static2,IE check
		
		IfNotExist % A_ProgramFiles "\Internet Explorer\iexplore.exe"
		{
			MsgBox,52,%name% - Information,Internet Explorer doesn't seem installed.`nChecked path: %A_ProgramFiles%\Internet Explorer\iexplore.exe`n`nPress ok and the program will exit or press cancel to continue.`n`nIf the Internet Explorer has been falsely judged as not installed, then please set the IEerror setting to 1.
			
			IfMsgBox, Yes
				ExitApp
		}
		Sleep 500
	}

	Gui, 99: font, s12 cGreen bold
		GuiControl, 99: font, Static2
	GuiControl, 99:,Static2,Ready
	
	GuiControl, 99: Enable, Button2

	If (AutoLogin = 1)
	{
		GuiControl, 99: Disable, Button2
		Sleep 500
		GoSub, submitinfo
	}
}
return

SubmitInfo:
{
	Gui, 99: Submit, nohide
	GuiControl, 99:, Edit1,
	GuiControl, 99:, Edit2,
	GuiControl, 99: Disable, Button2
	
	IniWrite,%AutoLogin%,%settingspath%,Settings,AutoLogin

	If (L_U = "")
	{
		TrayTip,%login_name%,Please enter an username.,3,2
		GuiControl, 99: Enable, Button2
		Return
	}
	If (L_P = "")
	{
		TrayTip,%login_name%,Please enter a password.,3,2
		GuiControl, 99: Enable, Button2
		Return
	}
	If (L_O = 1)
	{
		L_U_T := Crypt.Encrypt.StrEncrypt(L_U,"007",5,1)
		IniWrite,%L_U_T%,%settingspath%,Settings,L_Username

		L_P_T := Crypt.Encrypt.StrEncrypt(L_P,"007",5,1)
		IniWrite,%L_P_T%,%settingspath%,Settings,L_Password
		IniWrite,%L_O%,%settingspath%,Settings,L_Option
	}
	else
		IniWrite,%L_O%,%settingspath%,Settings,L_Option
		
	Gui, 99: font, s12 cBlue bold
		GuiControl, 99: font, Static2		
	GuiControl, 99:, Static2, Starting IE
	
	WB_counter++

	try
	{
		wb%WB_counter% := ComObjCreate("InternetExplorer.Application")	
		global ID_IE, PID
		WinGet, ID_IE, IDLast, ahk_class IEFrame
		WinGet, PID, PID, ahk_class IEFrame
		wb%WB_counter%.Visible := true
		If (IEvisible = "0")
			WinHide, ahk_class IEFrame
	}
	catch e
	{
		TrayTip,Error?,Error. Please wait a minute before restarting the tool.,3,1
	    MsgBox, 16,, % "Exception thrown!`n`nwhat: " e.what "`nfile: " e.file
	        . "`nline: " e.line "`nmessage: " e.message "`nextra: " e.extra
	    ExitApp
	}

	If (IEvisible = "0")
		WinHide, ahk_class IEFrame

	If (IEerror = "1")
		Enabled := ComObjError(true)
	If (IEerror = "0")
		Enabled := ComObjError(false)
	
	sleeptimer := 0


	global url, url2
	url2 = https://entgaming.net/bans/search.php?username=test&realm=
	url = https://entgaming.net/forum/ucp.php?mode=login

	wb%WB_counter%.Navigate(url)
	While wb%WB_counter%.readyState != 4 || wb%WB_counter%.document.readyState != "complete" || wb%WB_counter%.busy 
	{
		Sleep 250
		IF content contains NewErrorPageTemplate.css
		{
			GuiControl, 1:,Static1,Time out warning!
			errorCounter := 0
			Loop, 3
			{
				While wb%WB_counter%.readyState != 4 || wb%WB_counter%.document.readyState != "complete" || wb%WB_counter%.busy 
					Sleep, 100

				content := wb%WB_counter%.document.documentElement.outerHTML
				IF content contains NewErrorPageTemplate.css
				{
					errorCounter++
					Sleep 20000
					GuiControl, 1:,Static1,Time out: %errorCounter%
					If (errorCounter = "3")
					{
						MsgBox,48,%name%,Time out! Restart the GA.
						GoSub, stop
						ExitApp
					}

						wb%WB_counter%.Navigate(url)
						While wb%WB_counter%.readyState != 4 || wb%WB_counter%.document.readyState != "complete" || wb%WB_counter%.busy 
						    Sleep, 100
						wb%WB_counter%.document.all.username.value := L_U
						Sleep 100
						wb%WB_counter%.document.all.password.value := L_P
						Sleep 100
						tabname := wb%WB_counter%.locationname
						ControlSend,Internet Explorer_Server1,{Enter},%tabname%
				}

				If content not contains NewErrorPageTemplate.css
					Break
			}
		}
	}



	GuiControl, 99:, Static2, Logging in
	Sleep 250
	;msgbox % L_U "`n" L_P
	wb%WB_counter%.document.all.username.value := L_U
	Sleep 100
	wb%WB_counter%.document.all.password.value := L_P
	Sleep 100
	tabname := wb%WB_counter%.locationname
	Sleep 250
		ControlSend,Internet Explorer_Server1,{Enter},%tabname%

	
	While wb%WB_counter%.readyState != 4 || wb%WB_counter%.document.readyState != "complete" || wb%WB_counter%.busy 
	    Sleep, 100
	
	GuiControl, 99:, Static2, Login check
	
	wb%WB_counter%.Navigate(url2)
	While wb%WB_counter%.readyState != 4 || wb%WB_counter%.document.readyState != "complete" || wb%WB_counter%.busy 
	    Sleep, 1000
	
	taburl := wb%WB_counter%.LocationUrl
	If (taburl = url2)
	{
			Gui, 99: font, s12 cGreen bold
			GuiControl, 99: font, Static2
			GuiControl, 99:, Static2, Initiating PRISM
		Sleep 500
		Gui, 99: Destroy
		GoSub, Choose
	}
	Else If (taburl != url2)
	{
			Gui, 99: font, s12 cRed bold
			GuiControl, 99: font, Static2
			GuiControl, 99:, Static2,Error. Re-log.
	}
	;msgbox % taburl "`n" url2
	GuiControl, 99: Enable, Button2
}
return

Choose:
{
	IE_e := 0
	Gui, 5: default
	Gui, font, s11
		Gui, font, bold
		Gui, add, text,x5 y5 h25 w200,Please choose a methode:
		Gui, font, normal
	Gui, add, text,x5 y30 h25 w200 gGo,User Specific
	Gui, add, text,x5 y55 h25 w200 gGoAll,All Games
	Gui, font, strike
	Gui, add, text,x5 y80 h25 w200,Game Specific
	Gui, show, w210 h105,%name%
}
return

goAll:
{
	Gui, 1: destroy
	Gui, 5: Destroy

	If (counter > 10)
		counter := 10

	If (counter = ERROR || counter < 1)
		counter := 1

	Gui, 2: Default
	Gui, font, s11
	Gui, add, text, x5 y7,Index1:
	Gui, add, ComboBox, x70 y5 w150 h25 vIndex2 r5,0||20|40|60|80|100|120|140|180|180
	Gui, add, text, x5 y35,Index2:
	Gui, add, combobox, x70 y34 w150 h25 vIndex r5,12||20|40|60|80|100|120|140|160|180|200
	
	Gui, add, text, x5 y64,Game:
	Gui, add, DropDownList, x70 y61 w150 h25 choose4 r15 vGame,%gamenames%

	Gui, add, checkbox, y3 x225 h25 vVKeyUsers,KeyUsers
	Gui, add, checkbox, y28 x225 h25 vVKeyWords,KeyWords
	Gui, add, checkbox, y53 x225 h25 vVKeyUnique,KeyUnique
	If (created = "1" && IEvisible = "1")
		Gui, add, checkbox, y78 x225 h25 gHide4,IE Off
	Else
		Gui, add, checkbox, y78 x225 h25 gHide4,IE On

	Gui, add, button, x69 y86 w151 h25 gStartAll, Scan
	Gui, font, bold
	Gui, add, text, x5 y115 h25, Status:
	Gui, add, text, x70 y115 h25 w150, Standby

	Menu, MyMenuBar2, Add, Settings, Settings
	Menu, MyMenuBar2, Add, Logs, Logs
;	Menu, OpenMenu, Add, Log, OpenLog
;	Menu, OpenMenu, Add, IPs, OpenIPs
;	Menu, MyMenuBar2, Add, Open.., :OpenMenu

	Menu, MyMenuBar2, Add, Reload, iniread
	;Menu, MyMenuBar2, Add, Update, Update
	Menu, MyMenuBar2, Add, Specific User, Go
	Gui, Menu, MyMenuBar2

	Gui, show,w325 h140,%name%

		GoSub, Icons
			IfExist,%A_workingdir%\logo.ico
				Menu, Tray, icon, %A_workingdir%\logo.ico
					DllCall("uxtheme\SetWindowThemeAttribute", "ptr", WinExist(), "int", 1, "int64*", 6 | 6<<32, "uint", 8)
}
return

OpenIPs:
{
	IfExist, %A_ScriptDir%\P_IPs.txt
		Run, %A_ScriptDir%\P_IPs.txt
}
return

OpenLog:
{
	IfExist, %A_ScriptDir%\P_LOG.txt
		Run, %A_ScriptDir%\P_LOG.txt
}
return

StartAll:
{
	;IfNotExist, P_IPs.txt
	;	FileAppend,, P_IPs.txt

	/*ip_list =
	FileRead,ip_list,P_IPs.txt
		If (ip_list = "")
			ip_list =
*/
	Gui, 2: submit, NoHide

	abort_ := 0
	ltd_perma := 0
	ltd_wait := 0
	goall_ := 1

	pageInc := 1
	If (index = "12 latest"){
		sites := 1
		Index := 12
	}
	If (index = "20 latest"){
		sites := 1
		Index := 20
	}
	If (index = "40 latest"){
		sites := 2
		Index := 40
	}
	If (index = "60 latest"){
		sites := 3
		Index := 60
	}
	If (index = "80 latest"){
		sites := 4
		Index := 80
	}
	If (index = "100 latest"){
		sites := 5
		Index := 100
	}
	If (index = "120 latest"){
		sites := 6
		Index := 120
	}
	If (index = "140 latest"){
		sites := 7
		Index := 140
	}
	If (index = "160 latest"){
		sites := 8
		Index := 160
	}
	If (index = "180 latest"){
		sites := 9
		Index := 180
	}
	If (index = "200 latest"){
		sites := 10
		Index := 200
	}

	If (VKeyUsers = "0" && VKeyWords = "0" && VKeyUnique = "0")
	{
		TrayTip,Error,Please choose at least one key option.,3,2
		return
	}

	If (vKeyUsers = "1")
	{
		If (KeyUsers = A_Space)
		{
			TrayTip,Error,Settings value KeyUsers is empty.,3,2
			return
		}
	}

	If (VKeyWords = "1")
	{
		If (KeyWords = A_Space)
		{
			TrayTip,Error,Settings value KeyWords is empty.,3,2
			return
		}
	}

	If (vKeyUnique = "1")
	{
		If (KeyUnique = A_Space)
		{
			TrayTip,Error,Settings value KeyUnique is empty.,3,2
			return
		}
	}

	r_game := game
Menu, MyMenuBar2, Delete, Specific User

If (game = "Castle Fight")
	game = 1
If (game = "Are you a lucker")
	game = 2
If (game = "Pokemon Defense")
	game = 3
If (game = "DotA ap us/ca")
	game = 5
If (game = "Tropical Tower Wars")
	game = 6
If (game = "DotA rdem us/ca")
	game = 7
If (game = "DotA ar us/ca")
	game = 10
If (game = "DotA apem us/ca")
	game = 11
If (game = "Fortress Survival")
	game = 12
If (game = "Wintermaul One")
	game = 13
If (game = "Gem TD")
	game = 14
If (game = "Tree Tag")
	game = 15
If (game = "Civilization Wars")
	game = 16
If (game = "Legion TD Mega")
	game = 18
If (game = "Battleships Pro 5v5")
	game = 19
If (game = "YouTD v1.01")
	game = 20
If (game = "Vampirism Zero")
	game = 21
If (game = "Troll and Elves")
	game = 23
If (game = "SWAT Aftermath")
	game = 24
If (game = "Pudge Wars")
	game = 25
If (game = "lihl")
	game = 28
If (game = "Hero Wars 3v3")
	game = 29
If (game = "DotA HR us/ca -rd")
	game = 30
If (game = "TD Chaos War")
	game = 31
If (game = "LoD -sds6d2")
	game = 32
If (game = "Pig Farm TD")
	game = 33
If (game = "Power Towers")
	game = 34
If (game = "Legion TD Mega 1v1")
	game = 35
If (game = "Line Tower Wars")
	game = 36
If (game = "Angel Arena Allstars")
	game = 37
If (game = "DotA arem us/ca")
	game = 38
If (game = "\/\/ /\/\ \/\/")
	game = 39
If (game = "Azeroth Wars")
	game = 41
If (game = "Jurassic Park Survival")
	game = 47
If (game = "Green TD Mega")
	game = 48
If (game = "Enfo's TS")
	game = 49
If (game = "Team Line Tower Wars")
	game = 51
If (game = "Blood Tournament TD")
	game = 52
If (game = "Castle Defense")
	game = 53
If (game = "Hero Line Wars")
	game = 54
If (game = "Legion TD 3.5 Beta")
	game = 57
If (game = "White TD")
	game = 58
If (game = "Hero Line Wars Deluxe")
	game = 59
If (game = "Island Defense")
	game = 60
If (game = "entidih")
	game = 61
If (game = "Custom Hero Arena")
	game = 62
If (game = "X Hero Siege")
	game = 63
If (game = "DotA sdem A-BAL us/ca")
	game = 66
If (game = "DotA arem A-BAL us/ca")
	game = 67
If (game = "DotA ap AUTOBAL us/ca")
	game = 68
If (game = "DotA apem A-BAL us/ca")
	game = 69
If (game = "NWU -sdsm")
	game = 71
If (game = "LoD -sdems6bod2")
	game = 73
If (game = "Element TD")
	game = 74
If (game = "Hero Line Wars RoC")
	game = 78
If (game = "Legion TD Mega A-BAL")
	game = 79
If (game = "Rabbits vs Sheep")
	game = 82
If (game = "LoD -sds6bod2")
	game = 83
If (game = "WoW Arena Allstars")
	game = 84
If (game = "Survival")
	game = 85
If (game = "Burbenog TD")
	game = 86
If (game = "Risk Devolution")
	game = 87
If (game = "Tech Wars BC")
	game = 88
If (game = "Tom and Jerry")
	game = 89
If (game = "DotA apem euro")
	game = 90
If (game = "DotA ap euro")
	game = 91
If (game = "DotA apem A-BAL euro")
	game = 93
If (game = "DotA sdem euro")
	game = 94
If (game = "Legion TD Mega euro")
	game = 96

	GuiControl, 2: Disable, Button5
	GuiControl, 2:, Static5,Starting...

	url = https://entgaming.net/findreplay.php?player=&botid=%game%
	wb%WB_counter%.Navigate(url)

	GoSub, wait

	; http://www.autohotkey.com/board/topic/87023-making-ahk-find-clickable-links-and-move-the-cursor-to-found-linkword/?p=553443
	IDs = 

	GuiControl, 2:, Static5,Gathering game IDs...
		Loop % wb%WB_counter%.document.links.length
		{
			if (A_Index > Index2)
			{
				item := wb%WB_counter%.document.links.item[A_Index-1].href
				If item contains id=
				{
					StringReplace, item, item,https://entgaming.net/findstats.php?id=,,All
					IDs .= item "`n"
				}
				If (A_Index >= Index)
					break
			}
		}

	If (IDs = "")
	{
		MsgBox,48,%name%,No game links found.
		GuiControl, 2: Enable, Button5
		GuiControl, 2:, Static5, Standby
		return
	}

	counterIDs2 := 0
	ids_ = 
	Loop, parse, IDs,`n,`n
	{
		If ids_ not contains %A_LoopField%
		{
			ids_ .= A_LoopField "`n"
			counterIDs2++
		}
	}
	counterIDs2--
	ids := ids_
	;clipboard := IDs "`n" counterIDs2
	;msgbox stop

	info = 
	gn = 
	date = 
	content = 
	content_t = 
	countIDs := 0

		game_ = http://storage.entgaming.net/replay/view_replay.php?file=
		lobby_ = http://storage.entgaming.net/replay/download.php?f=

		If (game = "dota")
		{
			game_ = http://storage.entgaming.net/replay/view_replay.php?file=
			lobby_ = http://storage.entgaming.net/replay/download.php?f=
		}

		ltd_wait := 0
		If (game = "legionmega") ; except LTD beta which is on atl for both
		{
			ltd_wait := 1
			Gui, 10: font, s11
			Gui, 10: Add, text,,
(LTrim
Due to server complications, you'll have to choose whether you wish to have Legion TD Mega games or Legion TD Beta games filtered.

You've got the following two options:
- Mega to create a permanent link for Mega games.
- Beta to create a permanent link for Beta games.

If you choose a permanent solution, some games might not be accessible.
If you close the window, the latest link options will be chosen.
)
			Gui, 10: add, button,w80 h25 x5 gLTDmega,Mega
			Gui, 10: Add, button,w80 h25 x85 yp gLTDbeta,Beta
			Gui, 10: show,,Information
		}

			While (ltd_wait = "1")
				Sleep 250	

		If (game = "rvs")
		{
			game_ = http://storage.entgaming.net/replay/view_replay.php?file=
			lobby_ = http://storage.entgaming.net/replay/download.php?f=
		}

	Menu, MyMenuBar2, Add, Abort, Abort
	Loop, parse, IDs,`n,`n
	{
		;FileAppend,%A_index% : %A_LoopField%`n,%A_WorkingDir%\IDs.txt

		If (abort_ = "1")
			break

	/*
		IfWinNotExist, ahk_pid %PID% ;ahk_class IEFrame
		{
			MsgBox,48,%name%,Error. IE doesn't exist anymore. The tool has to restart.`n`nPress Ok and it exits.
			ExitApp
		}
	*/

		countIDs++
		If (A_LoopField = "")
			break

		; http://islanddefense1842150.w3g/
		GuiControl, 2:, Static5,% countIDs " : " counterIDs2 " - max: " (index-Index2)
		wb%WB_counter%.Navigate("https://entgaming.net/bans/game.php?id=" A_LoopField)
		GoSub, wait	

		info := wb%WB_counter%.document.documentElement.outerHTML

		If (info = "")
		{
			MsgBox,48,%name%,Error. The Internet Explorer doesn't exist anymore. The tool has to restart.`n`nPress Ok and it exits.
			GoSub, stop
			ExitApp
		}

		counter := 0
		needle2 = td sab=`"[\d]{1,3}`">[\d]{1,3}(\.)[\d]{1,3}(\.)[\d]{1,3}(\.)[\d]{1,3}
		Loop, parse, info,<,>
		{
			IF A_Index = 19
			{
				StringReplace, gn, A_LoopField, td sab=`"8`">,, All
				If gn contains td>
					StringTrimLeft, gn, gn, 3
			}
			If A_Index = 27
			{
				StringReplace, date, A_LoopField, td sab=`"12`">,, All
				If date contains td>
					StringTrimLeft, date, date, 3
				;break
			}
/*
		If (ProxyCheck = "1")
		{
			IF (A_Index > 92)
			{
				If A_LoopField contains search.php?username=
				{
					userInfo = 
				;	a href="search.php?username=dirtypig&amp;realm=europe.battle.net" sab="54">dirtypig
					StringReplace,userInfo,A_LoopField,a href=`"search.php?username=,,All
					StringReplace,userInfo,userInfo,&amp`;realm=,@,All
					string = `" sab=`"[\d]{1,3}`">(.*)
					userInfo := RegExReplace(userInfo,string,"")
				}

				If (ipFound = "1")
				{
					hostname := A_LoopField
						string = br sab=`"[\d]{1,3}`">
						hostname := RegexReplace(hostname,string,"")
						check := RegExMatch(hostname,OBShostnames)
						If (check = "1")
							warning_list .= "PROXY] " userInfo " " hostname "`n"

						ipFound := 0
				}

				If warning_list not contains %userInfo%
				{
					check := RegExMatch(A_LoopField,needle2) ; found IP line
					If (check = "1")
					{
						string =  td sab=`"[\d]{1,3}`">
						ip := RegExReplace(A_LoopField,string,"")
						StringReplace,ip,ip,%A_Space%,,All

						needle = [\d]{1,3}(\.)[\d]{1,3}(\.)[\d]{1,3}(\.)[\d]{1,3}
						check := RegExMatch(ip,needle) ; IP confirmed
						If (check = "1")
						{
							ipFound := 1 ; inform hostname next line
							If (proxycheck = "1") ; proxy enabled
							{
								counter++
								check := RegExmatch(ip_list,ip)
								;If (check != "0" && check != "-22" && check != "-21" && check != "-8" && check != "")
								If (check = "0")
								{
									show_w := 0
									ip_list .= ip ","
									GuiControl, 2:,Static5,Proxy check... (%counter%)

									HTTPRequest("http://whatismyipaddress.com/ip/" ip,requested_content)
									If requested_content contains You appear to be an automated script or have exceeded our query rate limits.
									{
										proxycheck := 0
										IniWrite,0,%settingspath%,Settings,ProxyCheck
										MsgBox,16,PRISM,ProxyCheck has been disabled.`n`nToo many queries.`nYou appear to be an automated script or have exceeded our query rate limits. Site terms and conditions do not allow for automated/script access.`nPlease wait one hour before coming back to the site.`n`nPRISM will go on as usual.
									}

									If requested_content contains %proxyfilter%
									{
										warning_list .= "PROXY1] " userInfo " " ip "`n"
										show_w := 1
									}

									If (show_w = "0") ; no double check
									{
										HTTPRequest("http://www.ip-adress.com/ip_lokalisieren/" ip,requested_content2)
										If requested_content2 contains %proxyfilter%
											warning_list .= "PROXY2] " userInfo " " ip "`n"						
									}
								}
							} ; proxy enabled?
						}
					}
				}
				
			*/
		;	} ; passed game info
		;}
		} ; info loop

/*
		IF (proxycheck = "1" && warning_list != "")
		{					
			IfNotExist,P_LOG.txt
				FileAppend,,P_LOG.txt

			start_f := 0
			IfExist,P_LOG.txt
			{
				FileRead,P_LOG_content,P_LOG.txt				
				Loop, parse, warning_list,`n,`n
				{
					If P_LOG_content not contains %A_LoopField%
					{
						If (A_LoopField != "")
						{
							FileAppend,% "[" A_DD "/" A_MM "/" A_YYYY " - " A_Hour ":" A_Min ":" A_Sec " " A_LoopField "`n",P_LOG.txt ;
						}
					}
				}
			}
		}
		*/

		If gn contains dota
		{
			If gn contains euro
			{
				game_ = http://storage.entgaming.net/replay/view_replay.php?file=
				lobby_ = http://storage.entgaming.net/replay/download.php?f=
			}

			If gn contains us/ca
			{
				game_ = http://storage.entgaming.net/replay/view_replay.php?file=
				lobby_ = http://storage.entgaming.net/replay/download.php?f=
			}
		}

		wb%WB_counter%.Navigate(game_ A_LoopField ".w3g")
		GoSub, wait

		temp := wb%WB_counter%.document.documentElement.outerHTML
		;FileAppend,%game_% %A_LoopField% .w3g`n,%A_WorkingDir%\IDs.txt
		If temp not contains Can't read replay file
		{
			If (temp != "")
			{
				Loop, parse, temp,`n,`n
				{
					If A_LoopField contains ChatWindow
						content_t .= A_LoopField "`n"
				}

					content .= date " :: (Game) " gn " :: " game_ A_LoopField ".w3g`n" content_t "`n`n"
			}
		}

		wb%WB_counter%.Navigate(lobby_ A_LoopField ".txt")
		GoSub, wait

			content_T := wb%WB_counter%.document.documentElement.outerHTML

		;	msgbox % content_t
		;	FileAppend,%lobby_% %A_LoopField% .txt`n,%A_WorkingDir%\IDs.txt
			If content_T not contains <title>HTTP 404:
			{
					content .= date " :: (Lobby) " gn " :: " lobby_ A_LoopField ".txt`n" content_t "`n`n"
		;			MsgBox,  % content
			}
			;msgbox % content
		;ToolTip % counterIDs2 "." countIDs "." counter_v "." Index "." A_Index
		If (countIDs = Index)
		{
			break
		}
	}
	Menu, MyMenuBar2, Delete, Abort
	GuiControl, 2:, Static5,Filtering...

/*
	IF (proxycheck = "1")
	{
		Sort, ip_list, U
		FileAppend, %ip_list%, P_IPs.txt
	}
	*/

	StringReplace, content, content,<br>,`n,All
	StringReplace, content, content,</span>,, All
	StringReplace, content, content,<div class=`"ChatWindow`" sab=`"40`">,,All
	StringReplace, content, content,<html><head></head><body sab=`"0`"><pre sab=`"1`">,, All
	StringReplace, content, content,</pre></body></html>,, All
	StringReplace, content, content,% A_space A_Space A_Space A_Space,, All
	
	needle = </div><div align="center" sab="[\d]+"> Copyleft Â© CTS - Dotaparser - Loaded in: [\d.]+ sec</div>
	content := RegExReplace(content,needle,"")

	needle = <span class="[a-z]+" style="font-weight: bold;" sab="[\d]+">
	content := RegExReplace(content,needle,"")

	needle = <span class="[a-z]+" style="font-weight: bold;">
	content := RegExReplace(content,needle,"")

	needle = <span class="" style="font-weight: bold;" sab="[\d]+">
	content := RegExReplace(content,needle,"")

	needle = <span class="[a-z]+" sab="[\d]+">
	content := RegExReplace(content,needle,"")

	needle = <br sab="[\d]+">
	content := RegExReplace(content,needle,"`n")

	found = 
	countLines := 0
	Loop, parse, content,`n,`n
	{
		If (VKeyUsers = "1")
		{
			If found not contains %A_LoopField%
			{
				line := A_LoopField
				Loop, parse, KeyUsers,`,`,
				{
					If line contains [%A_LoopField%],) %A_LoopField%:
						If line not contains %veto%
							{
								countLines++
								found .= line "`n"
							}
				}
			}
		}

		If (VKeyWords = "1")
		{
			If found not contains %A_LoopField%
			{
				If A_LoopField contains :: (Lobby)
					lobby_t := 1
				If A_LoopField contains :: (Game)
					lobby_t := 0

				If (lobby_t = 0)
				{
					;msgbox % A_LoopField "`n" KeyWords
					StringGetPos,pos,A_LoopField,:,L1,4
					pos += 2
					StringTrimLeft,line, A_LoopField, %pos%


				;	check := RegExMatch(line,vKeyWords)
				;	If (check = "1")
					If line contains %KeyWords%
					{
						If A_LoopField not contains %veto%
						{
							countLines++
							found .= A_LoopField "`n"
						}
					}
				}

				If (lobby_t = "1")
				{
					StringGetPos,pos,A_LoopField,:
					pos += 2
					StringTrimLeft, line, A_LoopField, %pos%

					;check := RegExMatch(line,vKeyWords)
					;If (check = "1")
					 If line contains %KeyWords%
					{
						If A_LoopField not contains %veto%
						{
							countLines++
							found .= A_LoopField "`n"
						}
					}
				}
			} ; end if found contains
		} ; end vKeyWords

		If (vVKeyUnique = "1")
		{
			If found not contains %A_LoopField%
				If A_LoopField contains %KeyUnique%
				{
					If A_LoopField not contains %veto%
					{
						countLines++
						found .= A_LoopField "`n"
					}
				}
		}

		If A_LoopField contains http://storage.entgaming.net/replay/download.php?f=,http://storage.entgaming.net/replay/view_replay.php?file=
			If found not contains %A_LoopField%
			{
				If A_LoopField not contains %veto%
				{
					If (found != "")
						found .= "`n" A_LoopField "`n"
					Else
						found .= A_LoopField "`n"
				}
			}
	}

	GuiControl, 2: Enable, Button5
	Menu, MyMenuBar2, Add, Specific User, go
	GuiControl, 2:, Static5,Standby
	Gosub, InitiateResult
}
return

go:
{
	game = http://storage.entgaming.net/replay/view_replay.php?file=
	lobby = http://storage.entgaming.net/replay/download.php?f=

	Gui, 2: Destroy
	Gui, 5: Destroy
	Loop, parse, Users,|,|
		counter := A_Index

	If (counter > 10)
		counter := 10

	If (counter = ERROR || counter < 1)
		counter := 1

;	Gosub, trayMenu
	Gui, 1: Default
	Gui, 1: font, s11
	Gui, add, text, x5 y8, Username:
	Gui, add, ComboBox, x85 y5 w150 h25 r%counter% vUser,%Users%
	Gui, add, text, x5 y36, Gateway:
	Gui, add, DDL, x85 y33 w150 h25 vGateway r7,|Europe|USeast|USwest|Asia|Garena|Econnect
	Gui, add, text, x5 y63,Games:
	Gui, add, DDL, x85 y60 w150 h25 vIndex r7, 12 latest||20 latest|40 latest|60 latest|80 latest|100 latest|120 latest|140 latest|160 latest|180 latest|200 latest
	Gui, add, checkbox, y5 x245 h25 vVKeyUsers,KeyUsers
	Gui, add, checkbox, y30 x245 h25 vVKeyWords,KeyWords
	Gui, add, checkbox, y55 x245 h25 vVKeyUnique,KeyUnique

	If (created = "1" && IEvisible = "1")
		Gui, add, checkbox, y80 x245 h25 gHide4,IE Off
	Else
		Gui, add, checkbox, y80 x245 h25 gHide4,IE On

	Gui, add, button, x84 y85 w151 h25 gStart, Scan
	Gui, font, bold
	Gui, add, text, x5 y112 h25, Status:
	Gui, add, text, x85 y113 h25 w300, Standby

	Menu, MyMenuBar1, Add, Settings, Settings
	Menu, MyMenuBar1, Add, Logs, logs
	Menu, MyMenuBar1, Add, Reload, iniread
	;Menu, MyMenuBar1, Add, Update, Update
	Menu, MyMenuBar1, Add, All Games, GoAll
	;Menu, MyMenuBar1, Add, Abort, abort
	Gui, Menu, MyMenuBar1

	Gui, show,w350 h137,%name%

	GoSub, Icons
		IfExist,%A_workingdir%\logo.ico
			Menu, Tray, icon, %A_workingdir%\logo.ico
				DllCall("uxtheme\SetWindowThemeAttribute", "ptr", WinExist(), "int", 1, "int64*", 6 | 6<<32, "uint", 8)
}
return

infoTray:
MsgBox,64,%name%,PRISM is developed by aRt)Y and only accessable by the ENT staff for gathering information.
Return

supporttray:
msgBox,64,%name%,Support is available on https://code.google.com/p/pdrmf/.`nYou can also email me at ProjectDRMF@gmail.com
return

iniread:
Iniread()
SoundPlay, *64
return

settings:
	IfExist % settingspath
		Run % settingspath
return

10Guiclose:
ltd_wait := 0
Gui, 10: Destroy
return

2GuiClose:
5GuiClose:
99GuiClose:
GuiClose:
{
	IniWrite,%A_DD%,%settingspath%,Settings,LastUsageDay
	GoSub, stop
	ExitApp
}
return

start:
{
	Gui, 1: submit, nohide
	abort_ := 0
	ltd_perma := 0
	ltd_wait := 0
	goall_ := 0

	If (user = "")
	{
		TrayTip, Error, Enter an username., 3, 2
		return
	}

	pageInc := 1
	If (index = "12 latest"){
		sites := 1
		Index := 12
	}
	If (index = "20 latest"){
		sites := 1
		Index := 20
	}
	If (index = "40 latest"){
		sites := 2
		Index := 40
	}
	If (index = "60 latest"){
		sites := 3
		Index := 60
	}
	If (index = "80 latest"){
		sites := 4
		Index := 80
	}
	If (index = "100 latest"){
		sites := 5
		Index := 100
	}
	If (index = "120 latest"){
		sites := 6
		Index := 120
	}
	If (index = "140 latest"){
		sites := 7
		Index := 140
	}
	If (index = "160 latest"){
		sites := 8
		Index := 160
	}
	If (index = "180 latest"){
		sites := 9
		Index := 180
	}
	If (index = "200 latest"){
		sites := 10
		Index := 200
	}

	If (VKeyUsers = "0" && VKeyWords = "0" && VKeyUnique = "0")
	{
		TrayTip,Information,Since no option has been chosen`, the whole unfiltered chatlog from %user% will be listed.,3,1
		;TrayTip,Error,Please choose at least one key option.,3,2
	}

/*
	If (vKeyUsers = "1")
	{
		If (KeyUsers = A_Space)
		{
			TrayTip,Error,Settings value KeyUsers is empty.,3,2
			return
		}
	}

	If (VKeyWords = "1")
	{
		If (KeyWords = A_Space)
		{
			TrayTip,Error,Settings value KeyWords is empty.,3,2
			return
		}
	}

	If (vKeyUnique = "1")
	{
		If (KeyUnique = A_Space)
		{
			TrayTip,Error,Settings value KeyUnique is empty.,3,2
			return
		}
	}
*/

	GuiControl, 1: Disable, Button5

	If (gateway = "Europe")
		gateway = europe.battle.net
	If (gateway = "USeast")
		gateway = USeast.battle.net
	If (gateway = "USwest")
		gateway = USwest.battle.net
	If (gateway = "Asia")
		gateway = Asia.battle.net
	If (gateway = "Garena")
		gateway = 
	If (gateway = "Econnect")
		gateway = entconnect

	If users not contains %user%
		IniWrite,%user%|%users%,%settingspath%,Settings,Users

	url = https://entgaming.net/bans/search.php?username=%user%&realm=%gateway%
	wb%WB_counter%.Navigate(url)

	GoSub, wait

	; http://www.autohotkey.com/board/topic/87023-making-ahk-find-clickable-links-and-move-the-cursor-to-found-linkword/?p=553443
	IDs = 
	GuiControl, 1:, Static5,Gathering game IDs...

		Loop % wb%WB_counter%.document.links.length
		{
			item := wb%WB_counter%.document.links.item[A_Index-1].href
			If item contains id=
			{
				StringReplace, item, item, https://entgaming.net/bans/game.php?id=,, All
				IDs .= item "`n"
			}
	
			If (pageInc = "1")
			{
				item2 := wb%WB_counter%.document.links.item[A_Index-1].outerHTML
				If item2 contains More</a>
				{
					more := item2
					break
				}
			}
		}

	If (more != "" && pageInc = "1")
	{
		StringReplace, more, more,<a href=`",,All
		needle = " sab="[\d]+">More</a>
		more := RegExReplace(more, needle,"")

		; http://www.w3schools.com/tags/ref_entities.asp
		StringReplace, more, more,&#62`;,>,All
		StringReplace, more, more,&#60`;,<,All
		StringReplace, more, more, &amp`;,&, All
		StringReplace, more, more,#28,),All
		StringReplace, more, more,#29,(,All

		wb%WB_counter%.Navigate("https://entgaming.net/bans/" more)
		GoSub, wait

		Loop % wb%WB_counter%.document.links.length
		{
			item := wb%WB_counter%.document.links.item[A_Index-1].href
			If item contains id=
			{
				StringReplace, item, item, https://entgaming.net/bans/game.php?id=,, All
				If IDs not contains item
					IDs .= item "`n"
			}
		}
	}

	If (IDs = "")
	{
		MsgBox,48,%name%,No game links found. Please correct the username.
		GuiControl, 1: Enable, Button5
		GuiControl, 1:, Static5,Standby
		return
	}

	counterIDs2 := 0
	ids_ = 
	Loop, parse, IDs,`n,`n
	{
		If ids_ not contains %A_LoopField%
		{
			ids_ .= A_LoopField "`n"
			counterIDs2++
		}
	}
	counterIDs2--
	ids := ids_

	info = 
	gn = 
	date = 
	content = 
	content_t = 
	countIDs := 0
	Menu, MyMenuBar1, Add, Abort, abort

	UsersList = 
	Loop, parse, IDs,`n,`n
	{

		If (abort_ = "1")
			break
	
	/*
		IfWinNotExist,ahk_pid %PID% ;ahk_class IEFrame
		{
			MsgBox,48,%name%,Error. IE doesn't exist anymore. The tool has to restart.`n`nPress Ok and it exits.
			ExitApp
		}
	*/

		countIDs++
		If (A_LoopField = "")
			break

		GuiControl, 1:, Static5,% countIDs " : " counterIDs2 " - max: " (index)
		wb%WB_counter%.Navigate("https://entgaming.net/bans/game.php?id=" A_LoopField)
		GoSub, wait	

		info := wb%WB_counter%.document.documentElement.outerHTML
		If (info = "")
		{
			MsgBox,48,%name%,Error. The Internet Explorer doesn't exist anymore. The tool has to restart.`n`nPress Ok and it exits.
			Gosub, stop
			ExitApp
		}

		/*
		If info not contains sab="
		{
			Loop, parse, info,<,>
			{
				If A_LoopField contains Date
				{
					d_index := A_Index
					d_index += 3
				}

				If A_LoopField contains Game name
				{
					gn_index := A_Index
					gn_index += 3
				}

				If (d_index = A_Index)
				{
					date := A_LoopField
					StringTrimLeft, date, date, 3
				}

				If (gn_index = A_Index)
				{
					gn := A_LoopField
					StringTrimleft, gn, gn, 3
				}
			}
		}
		*/
			Loop, parse, info,<,>
			{	
				IF A_Index = 19
				{
					StringReplace, gn, A_LoopField, td sab=`"8`">,, All
					If gn contains td>
						StringTrimLeft, gn, gn, 3
				}
				If A_Index = 27
				{
					StringReplace, date, A_LoopField, td sab=`"12`">,, All
					If date contains td>
						StringTrimLeft, date, date, 3
					If (trackUsers = "0")
						break
				}

				If (trackUsers = "1")
				{
					If A_LoopField contains search.php?username=
					{
						       ; a href="search.php?username=metall-drago&amp;realm=" sab="100">
						needle = a href="search\.php\?username=(.*)&amp;realm=(.*)" sab="(.*)">
						userslist .= RegExReplace(A_LoopField,needle,"") "`n"
					}
				}
			}

If (ltd_perma = "0")
{
	game_ = http://storage.entgaming.net/replay/view_replay.php?file=
	lobby_ = http://storage.entgaming.net/replay/download.php?f=

	If gn contains castle fight
		game = castlefight
	If gn contains Civilization Wars
		game = civwars
	If gn contains Hero Line Wars
		game = herolinewars
	If gn contains Island Defense
		game = islanddefense
	If gn contains Legion TD Mega
		game = legionmega
	If gn contains NWU
		game = nwu
	If gn contains Rabbits vs Sheep
		game = rvs
	If gn contains Risk Devolution
		game = riskdevo
	If gn contains Tree Tag
		game = treetag
	If gn contains Castle Fight 1v1
		game = cfone
	If gn contains Legion TD Mega HR
		game = legionmega2
	If gn contains LIHL
		game = lihl

		If gn contains dota
		{
			If gn contains euro
			{
				game_ = http://storage.entgaming.net/replay/view_replay.php?file=
				lobby_ = http://storage.entgaming.net/replay/download.php?f=
			}

			If gn contains us/ca
			{
				game_ = http://storage.entgaming.net/replay/view_replay.php?file=
				lobby_ = http://storage.entgaming.net/replay/download.php?f=
			}
		}

		ltd_wait := 0
		If (game = "legionmega") ; except LTD beta which is on atl for both
		{
			ltd_wait := 1
			Gui, 10: font, s11
			Gui, 10: Add, text,,
(LTrim
Due to server complications, you'll have to choose whether you wish to have Legion TD Mega games or Legion TD Beta games filtered.

You've got the following four options:
- Yes to create a temporarily link for LTD Mega games.
- No to create a temporarily link for LTD Beta games.
- Mega to create a permanent link for Mega games.
- Beta to create a permanent link for Beta games.

If you choose a permanent solution, some games might not be accessible.
If you close the window, the latest link options will be chosen.
)

			Gui, 10: add, button,w80 h25 x5 gLTDyes,Yes
			Gui, 10: Add, button,w80 h25 x85 yp gLTDno,No
			Gui, 10: Add, button,w80 h25 x165 yp gLTDmega,Mega
			Gui, 10: Add, button,w80 h25 x245 yp gLTDbeta,Beta
			Gui, 10: show,,Information
		}

		While (ltd_wait = "1")
			Sleep 250

		If (game = "rvs")
		{
			game_ = http://storage.entgaming.net/replay/view_replay.php?file=
			lobby_ = http://storage.entgaming.net/replay/download.php?f=
		}		
}

		wb%WB_counter%.Navigate(game_ A_LoopField ".w3g")
		GoSub, wait

		temp := wb%WB_counter%.document.documentElement.outerHTML
		If temp not contains Can't read replay file
		{
			If (temp != "")
			{
				Loop, parse, temp,`n,`n
				{
					If A_LoopField contains ChatWindow
						content_t .= A_LoopField "`n"
				}

					content .= date " :: (Game) " gn " :: " game_ A_LoopField ".w3g`n" content_t "`n`n"
			}
		}

		wb%WB_counter%.Navigate(lobby_ A_LoopField ".txt")
		GoSub, wait

			content_T := wb%WB_counter%.document.documentElement.outerHTML
			If content_T not contains <title>HTTP 404:
			{
					content .= date " :: (Lobby) " gn " :: " lobby_ A_LoopField ".txt`n" content_t "`n`n"
			}

		If (A_Index = Index)
			break
	}
	Menu, MyMenuBar1, Delete, Abort

	StringReplace, content, content,<br>,`n,All
	StringReplace, content, content,</span>,, All
	StringReplace, content, content,<div class=`"ChatWindow`" sab=`"40`">,,All
	StringReplace, content, content,<html><head></head><body sab=`"0`"><pre sab=`"1`">,, All
	StringReplace, content, content,</pre></body></html>,, All
	StringReplace, content, content,% A_space A_Space A_Space A_Space,, All
	
	needle = </div><div align="center" sab="[\d]+"> Copyleft Â© CTS - Dotaparser - Loaded in: [\d.]+ sec</div>
	content := RegExReplace(content,needle,"")

	needle = <span class="[a-z]+" style="font-weight: bold;" sab="[\d]+">
	content := RegExReplace(content,needle,"")

	needle = <span class="[a-z]+" style="font-weight: bold;">
	content := RegExReplace(content,needle,"")

	needle = <span class="" style="font-weight: bold;" sab="[\d]+">
	content := RegExReplace(content,needle,"")

	needle = <span class="[a-z]+" sab="[\d]+">
	content := RegExReplace(content,needle,"")

	needle = <br sab="[\d]+">
	content := RegExReplace(content,needle,"`n")

	GuiControl, 1:, Static5,Filtering...
	found = 
	countLines := 0
	Loop, parse, content,`n,`n
	{
		If (users != "")
		{
			If found not contains %A_LoopField%
			{
				If A_LoopField contains [%user%],) %user%:
				{
					If A_LoopField not contains %veto%
							{
								countLines++
								found .= A_LoopField "`n"
							}
				}
			}
		}
		
		If (VKeyUsers = "1")
		{
			If found not contains %A_LoopField%
			{
				line := A_LoopField
				Loop, parse, KeyUsers,`,`,
				{
					If line contains [%A_LoopField%],) %A_LoopField%:
					{

						If line not contains %veto%
							{
								countLines++
								found .= line "`n"
							}
					}
				}
			}
		}

		If (VKeyWords = "1")
		{
			If found not contains %A_LoopField%
			{
				If A_LoopField contains :: (Lobby)
					lobby_t := 1
				If A_LoopField contains :: (Game)
					lobby_t := 0

				If (lobby_t = "0")
				{
					StringGetPos,pos,A_LoopField,:,L1,4
					pos += 2
					StringTrimLeft, line, A_LoopField, %pos%

				;	check := RegExMatch(line,KeyWords)
				;	If (check = "1")
				If line contains %KeyWords%
					{
						If line not contains %veto%
						{
							countLines++
							found .= A_LoopField "`n"
						}
					}
				}

				If (lobby_t = "1")
				{
					StringGetPos,pos,A_LoopField,:
					pos += 2
					StringTrimLeft, line, A_LoopField, %pos%
					
				;	check := RegExMatch(line,KeyWords)
				;	If (check = "1")
				If line contains %KeyWords%
					{
						If line not contains %veto%
						{
							countLines++
							found .= A_LoopField "`n"
						}
					}
				}
			} ; end if found contains
		} ; end vKeyWords

		If (vVKeyUnique = "1")
		{
			If found not contains %A_LoopField%
			{
				If A_LoopField contains %KeyUnique%
				{
					If A_LoopField not contains %veto%
					{
						countLines++
						found .= A_LoopField "`n"
					}
				}
			}
		}

		If A_LoopField contains http://storage.entgaming.net/replay/download.php?f=,http://storage.entgaming.net/replay/view_replay.php?file=
		{
			If found not contains %A_LoopField%
			{
				If A_LoopField not contains %veto%
				{
					If (found != "")
						found .= "`n" A_LoopField "`n"
					Else
						found .= A_LoopField "`n"
				}
			}
		}
	}
	
	replacedlist = 
	userslist2 = 
	userslist3 = 
	Loop, parse, userslist,`n
	{
		If (A_LoopField != "")
		{
			If replacedList not contains %A_LoopField%
			{
				replacedlist .= A_LoopField ","
				RegExReplace(userslist,"i)" A_LoopField,"",Amount,-1,1)
				If (Amount >= UserIndex && A_LoopField != User)
					userslist2 .= A_LoopField " : " Amount "`n"
			}
		}
	}

	userslist3 := userslist2

	GuiControl, 1: Enable, Button5
	GuiControl, 1:, Static5,Standby
	GoSub, InitiateResult
}
return

abort:
{
	global abort_ := 1
	;TrayTip, Aborted!, Result will not be filtered., 3, 2
}
return

LTDno:
{
	game_ = http://storage.entgaming.net/replay/view_replay.php?file=
	lobby_ = http://storage.entgaming.net/replay/download.php?f=
	ltd_wait := 0
	Gui, 10: Destroy
}
return

LTDyes:
{
	game_ = http://storage.entgaming.net/replay/view_replay.php?file=
	lobby_ = http://storage.entgaming.net/replay/download.php?f=
	ltd_wait := 0
	Gui, 10: Destroy
}
return

LTDmega:
{
	game_ = http://storage.entgaming.net/replay/view_replay.php?file=
	lobby_ = http://storage.entgaming.net/replay/download.php?f=
	ltd_wait := 0
	ltd_perma := 1
	Gui, 10: Destroy
}
return

LTDbeta:
{
	game_ = http://storage.entgaming.net/replay/view_replay.php?file=
	lobby_ = http://storage.entgaming.net/replay/download.php?f=
	ltd_wait := 0
	ltd_perma := 1
	Gui, 10: Destroy
}
return

InitiateResult:
{
	windownumber++
	test++

	If (test < 3)
		test := 3
	If (test = 99)
		test := 3

			Gui, %test%: Default
			Gui, %test%: Font, s%size%
			Menu, MyMenuBar4, Add, Save Result...,SaveFile
			Gui, %test%: Menu, MyMenuBar4

			If (goall_ = "1")
				Gui, %test%: add, ListView,+ReadOnly NoSortHdr altsubmit -vscroll -hscroll w%A_ScreenWidth% h%A_ScreenHeight%,Result for %r_game% ;h610 gcopy
			If (goall_ = "0")
				Gui, %test%: add, ListView,+ReadOnly NoSortHdr altsubmit -vscroll -hscroll w%A_ScreenWidth% h%A_ScreenHeight%,% user "@" gateway
			GuiControl, %test%: Move, SysListView321, % "x" 0 "y" 0 "w"A_ScreenWidth-5 "h"A_ScreenHeight-70
			Gui,%test%: +resize
			OnMessage(0x203,"WM_LBUTTONDBLCLK")
			OnMessage(0x204,"WM_RBUTTONDOWN")

				If (userslist3 != "" && trackusers = "1")
				{
					LV_Add("","Track Users Result:")
					Loop, parse, userslist3,`n,`n
						LV_Add("",A_LoopField)
					userslist3 = 
				}

				SaveAs = 
				If found contains ],[,),(
				{
					Loop, parse, found,`n,`n
					{
						SaveAs .= A_LoopField "`n"
						LV_Add("",A_LoopField)
					}
				}
				Else
					LV_Add("", "No result. Files might have already been deleted.")

				Loop, 18 ; result space
					LV_ADD("","")

			Gui,%test%: show,w1015 h610,PRISM - wID: %test% | gIDs: %countIDs% (%Index2% - %index%) | Lines: %countLines%
			return
}
return

SaveFile:
{
	IfNotExist, %A_WorkingDir%\Logs
		FileCreateDir, %A_workingdir%\Logs

	name := A_YYYY A_MM A_DD A_Hour A_Min A_Sec
	FileAppend,%SaveAs%, % A_WorkingDir "\Logs\" name ".txt"

	IfExist, % A_WorkingDir "\Logs\" name ".txt"
		TrayTip, Created, % "\Logs\" name ".txt", 3, 1
}
return

logs:
{
	IfNotExist, % A_WorkingDir "\Logs\"
		MsgBox,48,%name%,No logs have been saved, yet.
	IfExist, % A_WorkingDir "\Logs\"
		Run, % A_WorkingDir "\Logs\"
}
return

/*
Copy:
{
	If (A_GUI > 2 && A_EventInfo  != "0" && A_GuiEvent = "RightClick")
	{
		ControlGet, row_data, List, Selected, SysListView321
		If (clipboard != "")
				Clipboard .= "`n" row_data

		If (clipboard = "")
			clipboard .= row_data

		If row_data contains s12.entgaming.net/replay/,ee.entgaming.net/replay/,atl.entgaming.net/replay/
			Clipboard := row_data

		SoundPlay, *64
	}
}
return
*/

WM_LBUTTONDBLCLK(wParam,lParam)
{
	If (A_GUI > 2)
	{
		row := LV_getNext("","Focused")
	    LV_GetText(RowText, row)
	    
	    If RowText contains http://storage.entgaming.net/replay/replays,http://storage.entgaming.net/replay/view_replay.php?file=
	    {
	    	StringGetPos, pos, rowtext, ::, r,0
	    	StringTrimLeft, rowtext, rowtext, % (pos+3)
	    	Run % rowtext
	    }

		; test = [xxx(]: haha im in new zealand
		; test2 = (01:02 / Allied) xx_xxx: he will get kicked
	    check := RegExMatch(RowText,"\[(.*)]:(.*)",Found)
	    If (check = "1"){
			StringTrimLeft,Found,Found,1
			StringGetPos,pos,found,]:,L
			StringLen,len,found
			StringTrimRight,found,found,len - pos
				Run % "https://entgaming.net/bans/alias.php?player=" Found
		}

	    check := RegExMatch(RowText,"\([\d]{2,2}:[\d]{2,2} / (Allied|All)\) (.*):",Found)
	    If (check = "1"){
			StringTrimRight,Found,Found,1
			StringGetPos, pos, Found, ), L
			StringTrimLeft,Found,Found,% Pos + 2
				Run % "https://entgaming.net/bans/alias.php?player=" Found
		}
	}
}
return

WM_RBUTTONDOWN(wParam,lParam)
{
	StartTime := A_TickCount
	While GetKeyState("RButton", "D")
	{
		Loop
		{
			ElapsedTime := A_TickCount - StartTime
			If (ElapsedTime > 750)
			{
				Clipboard =
				TrayTip,%ElapsedTime% ms,Clipboard cleared,3,1
				return
			}

			If !GetKeyState("RButton", "D")
				break
			Sleep 50
		}
	}

	ElapsedTime := A_TickCount - StartTime
	If (ElapsedTime < 750)
	{
		;If (A_GUI > 2 && A_EventInfo  != "0" && A_GuiEvent = "RightClick")
		ControlGet, row_data, List, Selected, SysListView321
		If (clipboard != "")
			Clipboard .= "`n" row_data

		If (clipboard = "")
			clipboard := row_data

		If row_data contains http://storage.entgaming.net/replay/view_replay.php?file=,http://storage.entgaming.net/replay/view_replay.php?file=
			Clipboard := row_data

		SoundPlay, *64
	}
}
return

/*
Hide4:
{
	ControlGetText,text,Button5,%name%

	If text contains On
	{
		WinShow, ahk_class IEFrame
		GuiControl, %A_GUI%:, Button5,IE Off
	}

	If text contains Off
	{
		WinHide, ahk_class IEFrame
		GuiControl, %A_GUI%:, Button5,IE On
	}
}
return
*/

Hide4: ; toggle IE
{
	global e := !e

	If (e)
	{
		WinShow, ahk_Id %ID_IE%
		GuiControl, 1:, Button7,IE Off
		GuiControl, 2:, Button7,IE Off
	}
	Else
	If (!e)
	{
		WinHide, ahk_id %ID_IE%
		GuiControl, 1:, Button7,IE On
		GuiControl, 2:, Button7,IE On
	}
}
return

Stop:
{
	viaStop := 1
	global stop := 1
	global toggle:=!toggle
	
	Gui, 1: Destroy
	wb%WB_counter%.quit()	
	WinGet, checkName, ProcessName, ahk_ID %ID%
	Sleep 250
	If (checkName = "iexplore.exe")
		Process, close, %ID%
	ExitApp

}
return

wait:
{
;	If (!WinExist("ahk_pid" PID) || !WinExist("ahk_id" ID))
;		ExitApp

	sleeptimer := 0
	While wb%WB_counter%.readyState != 4 || wb%WB_counter%.document.readyState != "complete" || wb%WB_counter%.busy 
	{
		If (sleeptimer >= 20000)
		{
			TrayTip, Timeout!, Skipping ID, 3, 2
			IE_e++
			break
		}

	    Sleep, 1000
		sleeptimer += 1000
	}

	If (IE_e >= "3")
	{
		MsgBox,48,%name%,The Internet Explorer doesn't seem to exist anymore.`n`nThe program will exit.
		wb%wb_counter%.quit()
		ExitApp
	}
}
return

#IfWinActive, ahk_class AutoHotkeyGUI
^f::
{
	SetTitleMatchMode, RegEx
	WinGetClass,Class,A
	If (Class != "AutoHotkeyGUI")
		return

	; PRISM - wID: %test% | gIDs: %countIDs% | Lines: %countLines%
	WinGet,WinCheck,list,PRISM - wID: [\d]+ `| gIDs: [\d]+ `| Lines: [\d]+
	If (WinCheck = 0)
	{
		TrayTip,No GUI found!,%A_Space%,3,2
		return
	}

	foundR := 0 ; for error box
	allLines := 0 ; for auto selection on 'All'
	RemoveR := 0 ; to disable removing loop
	RowNumber := 0

	InPutBox,SearchFor,What are you looking for?,Please enter something to search for.,,240,100
	If ErrorLevel
		return
	else
	{
		Gui, %test%: Default
		counter := 0
		Loop, % LV_GetCount()
		{
			LV_GetText(line,A_index,1)
			If line contains %searchfor%
			{
				foundR := 1

				If (AllLines = "0")
				{
					MsgBox,67,ResultCrawler,Found!`nWhich line(s) of the result would you like to select?
				}
				else
				{
						LV_Modify(A_index, "Select")
						LV_Modify(A_index, "Focus")
				}

					IfMsgBox, Cancel
					{
						foundR := 1
						break
						return
					}

					IfMsgBox, Yes
					{
						If (RemoveR = 0)
						{
							Loop ; first remove current selected lines
							{
								rowNumber := LV_GetNext("F")
								If (rowNumber = 0)
							  		break
								LV_Modify(rowNumber, "-Select")
							}
							
							LV_Modify(A_index, "Select")
							LV_Modify(A_index, "Focus")
							LV_Modify(A_index, "Vis")
							RemoveR := 1
						}

							AllLines := 1
					}

					IfMsgBox, No
					{
						Loop,
						{
							rowNumber := LV_GetNext("F")
							LV_Modify(rowNumber, "-Select")
							If (rowNumber = 0)
						  		break
						}

						LV_Modify(A_index, "Focus")
						LV_Modify(A_index, "Select")
						LV_Modify(A_index, "Vis")
						return
					}
					counter++
			}
		}

		If (foundR = "0")
		{
			MsgBox,64,ResultCrawler,Nothing found...,4
				return
		}
		else
			TrayTip,Lines found:,%counter%,3,1
	}
}
return

^r::
{
	SetTitleMatchMode, RegEx
	WinGetClass,Class,A
	If (Class != "AutoHotkeyGUI")
		return

	WinGet,WinCheck,list,PRISM - wID: [\d]+ `| gIDs: [\d]+ `| Lines: [\d]+
	If (WinCheck = 0)
	{
		TrayTip,No GUI found!,%A_Space%,3,2
		return
	}

	InPutBox,SearchFor,What do you want to remove?,Please enter keyword(s).,,260,100
	If ErrorLevel
		return
	else
	{
	Gui, %test%: Default
	found := 0
	line = 
	counter := 0
	rlines := 0

	Loop, 10
	{
		Loop, % LV_GetCount()
		{
			If (counter != "0")
				RLines += counter

			counter := 0
			LV_GetText(line,A_index,1)
			If line contains %searchfor%
			{
				found := 1
				LV_Delete(A_Index)
				counter++
			}
		}
	}

	If (found = "0")
	{
		MsgBox,64,ResultCrawler,Nothing found...,4
			return
	}
	else
		TrayTip, Lines removed:,%rlines%,3,1

	}
}
return
#If

iniwrite:
{
	IniWrite,%version%,%settingspath%,Settings,Version
	IniWrite,0,%settingspath%,Settings,IEerror
	IniWrite,0,%settingspath%,Settings,IEvisible
	IniWrite,11,%settingspath%,Settings,size
	IniWrite,%A_DD%,%settingspath%,Settings,LastUsageDay
	InIWrite,%A_Space%,%Settingspath%,Settings,L_Username
	IniWrite,%A_Space%,%Settingspath%,Settings,L_Password
	IniWrite,1,%settingspath%,Settings,L_Option
	IniWrite,0,%settingspath%,Settings,AutoLogin
	IniWrite,%A_Space%,%settingspath%,Settings,KeyUsers
	IniWrite,%A_Space%,%Settingspath%,Settings,KeyWords
	Iniwrite,%A_Space%,%Settingspath%,Settings,KeyUnique
	IniWrite,%A_space%,%Settingspath%,Settings,Users
	IniWrite,0,%settingspath%,Settings,trackUsers
	IniWrite,5,%settingspath%,Settings,UserIndex
;	IniWrite,0,%settingspath%,Settings,proxycheck
;	IniWrite,vpn.`,vpn-`,-vpn`,.vpn,%settingspath%,settings,OBShostnames
;	IniWrite,Anonymous Proxy`,Confirmed proxy server`,Open Proxy Server`,Network sharing device`,Dedicated Server Hosting,%settingspath%,Settings,ProxyFilter
	IniWrite,[System]`,[CloudGnome]`,00:00`,: ANNOUNCEMENT:`,more votes are needed to pass`,*** player: [`,** Note`,<img class`,<img id=`, votekick `,before the game will automatically`,<p id="moreinfoseehelp"`,,%settingspath%,Settings,Veto
	IniWrite,https://code.google.com/p/pdrmf/wiki/Preadme,%settingspath%,Settings,Readme
	IniWrite,https://code.google.com/p/pdrmf/wiki/Pchangelog,%settingspath%,Settings,Changelog
	IniWrite,https://clanent.net/openstats/?u=,%settingspath%,Settings,UserLink
	IniWrite,0,%settingspath%,Settings,Debug
	IniWrite,Castle Fight|Are you a lucker|Pokemon Defense|DotA ap us/ca|Tropical Tower Wars|DotA rdem us/ca|DotA apem us/ca|Fortress Survival|Wintermaul One|Gem TD|Tree Tag|Civilization Wars|Legion TD MEga|Battleships Pro 5v5|YouTD v1.01|Vampirism Zero|Troll and Elves|SWAT Aftermath|Pudge Wars|lihl|Hero Wars 3v3|DotA HR us/ca -rd|TD Chaos War|LoD -sds6d2|Pig Farm TD|Power Towers|Legion TD Mega 1v1|Line Tower Wars|Angel Arena Allstars|DotA arem us/ca|\/\/ /\/\ \/\/|Azeroth Wars|Jurassic Park Survival|Green TD Mega|Enfo's TS|Team Line Tower Wars|Blood Tournament TD|Castle Defense|Hero Line Wars|Legion TD 3.5 Beta|White TD|Hero Line Wars Deluxe|Island Defense|entidih|Custom Hero Arena|X Hero Siege|DotA sdem A-BAL us/ca|DotA arem A-BAL us/ca|DotA ap AUTOBAL us/ca|DotA apem A-BAL us/ca|NWU -sdsm|LoD -sdems6bod2|Element TD|Hero Line Wars RoC|Legion TD Mega A-BAL|Rabbits vs Sheep|LoD -sds6bod2|WoW Arena Allstars|Survival|Burbenog TD|Risk Devoultion|Tech Wars BC|Tom and Jerry|DotA apem euro|DotA apem A-BAL euro|DotA sdem euro|Legion TD Mega euro,%settingspath%,Settings,Gamenames
}
return

IniRead() {
global
	IniRead,VersionCheck,%settingspath%,Settings,Version
	IniRead,IEerror,%settingspath%,Settings,IEerror
	IniRead,IEvisible,%Settingspath%,Settings,IEvisible
	IniRead,LastUsageDay,%settingspath%,Settings,LastUsageDay
	IniRead,L_U,%Settingspath%,Settings,L_Username
	IniRead,L_P,%settingspath%,Settings,L_Password
	IniRead,L_O,%Settingspath%,Settings,L_Option
	IniRead,AutoLogin,%settingspath%,Settings,AutoLogin
	IniRead,KeyUsers,%Settingspath%,Settings,KeyUsers
	IniRead,KeyWords,%settingspath%,Settings,KeyWords
	IniRead,KeyUnique,%settingspath%,Settings,KeyUnique
	IniRead,Users,%settingspath%,Settings,Users
	IniRead,trackusers,%settingspath%,Settings,trackUsers
	IniRead,userIndex,%settingspath%,Settings,userIndex
	InIRead,Veto,%settingspath%,Settings,Veto
	IniRead,UserLink,%settingspath%,Settings,UserLink
	IniRead,size,%settingspath%,Settings,size
	IniRead,gamenames,%settingspath%,Settings,Gamenames
;	IniRead,ProxyFilter,%settingspath%,Settings,ProxyFilter
;	IniRead,proxycheck,%settingspath%,Settings,proxycheck
;	IniRead,OBShostnames,%settingspath%,Settings,OBShostnames
}
return

install:
{
	IniWrite,%version%,%settingspath%,Settings,Version

	IniRead,IEerror,%settingspath%,Settings,IEerror
		If IEerror = error
			IniWrite,0,%settingspath%,Settings,IEerror
			
	IniRead,IEvisible,%settingspath%,Settings,IEvisible
		If IEvisible = Error
			IniWrite,0,%settingspath%,Settings,IEvisible
			
	IniRead,size,%settingspath%,Settings,size
		If size = Error
			IniWrite,11,%settingspath%,Settings,size
			
	IniRead,LastUsageDay,%settingspath%,Settings,LastUsageDay
		If LastUsageDay = Error
			IniWrite,%A_DD%,%settingspath%,Settings,LastUsageDay
			
	IniRead,L_U,%settingspath%,Settings,L_Username
		If L_U = Error
			IniWrite,%A_Space%,%settingspath%,Settings,L_Username
			
	IniRead,L_P,%settingspath%,Settings,L_Password
		If L_P = Error
			IniWrite,%A_Space%,%settingspath%,Settings,L_Password
			
	IniRead,L_O,%settingspath%,Settings,L_Option
		If L_O = Error
			IniWrite,1,%settingspath%,Settings,L_Option
		
	IniRead,AutoLogin,%settingspath%,Settings,AutoLogin
		If AutoLogin = Error
			IniWrite,0,%settingspath%,Settings,AutoLogin

	IniRead,KeyWords,%settingspath%,Settings,KeyWords
		If KeyWords = Error
			IniWrite,%A_Space%,%settingspath%,Settings,KeyWords

	IniRead,KeyUsers,%settingspath%,Settings,KeyUsers
		If KeyUsers = Error
			IniWrite,%A_Space%,%settingspath%,Settings,KeyUsers

	IniRead,KeyUnique,%settingspath%,Settings,KeyUnique
		If KeyUnique = Error
			Iniwrite,%A_Space%,%Settingspath%,Settings,KeyUnique

	IniRead,Users,%settingspath%,Settings,Users
		If Users = Error
			Iniwrite,%A_Space%,%Settingspath%,Settings,Users

	IniRead,trackUsers,%settingspath%,Settings,trackUsers
		If trackUsers = Error
			Iniwrite,0,%Settingspath%,Settings,trackUsers

	IniRead,UserIndex,%settingspath%,Settings,UserIndex
		If UserIndex = Error
			Iniwrite,5,%Settingspath%,Settings,UserIndex

/*	IniRead,OBShostnames,%settingspath%,Settings,OBShostnames
		If OBShostnames = Error
			IniWrite,vpn.`,vpn-`,-vpn`,.vpn,%settingspath%,settings,OBShostnames

	IniRead,ProxyFilter,%settingspath%,Settings,ProxyFilter
		If ProxyFilter = Error
			IniWrite,Anonymous Proxy`,Confirmed proxy server`,Open Proxy Server`,Network sharing device`,Dedicated Server Hosting,%settingspath%,Settings,ProxyFilter

	IniRead,proxycheck,%settingspath%,Settings,proxycheck
		If proxycheck = Error
			IniWrite,0,%settingspath%,Settings,proxycheck
*/
	IniRead,Veto,%settingspath%,Settings,Veto
		If Veto = Error
			IniWrite,[System]`,[CloudGnome]`,00:00`,: ANNOUNCEMENT:`,more votes are needed to pass`,*** player: [`,** Note`,<img class`,<img id=`, votekick `,before the game will automatically`,<p id="moreinfoseehelp"`,,%settingspath%,Settings,Veto
	
	IniRead,Link2,%settingspath%,Settings,Readme
		If Link2 = error
			IniWrite,https://code.google.com/p/pdrmf/wiki/Preadme,%settingspath%,Settings,Readme
			
	IniRead,Changelog,%settingspath%,Settings,Changelog
		IF Changelog = error
			IniWrite,https://code.google.com/p/pdrmf/wiki/Pchangelog,%settingspath%,Settings,Changelog

	IniRead,gamenames,%settingspath%,Settings,gamenames
		If gamenames = Error
				IniWrite,Castle Fight|Are you a lucker|Pokemon Defense|DotA ap us/ca|Tropical Tower Wars|DotA rdem us/ca|DotA apem us/ca|Fortress Survival|Wintermaul One|Gem TD|Tree Tag|Civilization Wars|Legion TD MEga|Battleships Pro 5v5|YouTD v1.01|Vampirism Zero|Troll and Elves|SWAT Aftermath|Pudge Wars|lihl|Hero Wars 3v3|DotA HR us/ca -rd|TD Chaos War|LoD -sds6d2|Pig Farm TD|Power Towers|Legion TD Mega 1v1|Line Tower Wars|Angel Arena Allstars|DotA arem us/ca|\/\/ /\/\ \/\/|Azeroth Wars|Jurassic Park Survival|Green TD Mega|Enfo's TS|Team Line Tower Wars|Blood Tournament TD|Castle Defense|Hero Line Wars|Legion TD 3.5 Beta|White TD|Hero Line Wars Deluxe|Island Defense|entidih|Custom Hero Arena|X Hero Siege|DotA sdem A-BAL us/ca|DotA arem A-BAL us/ca|DotA ap AUTOBAL us/ca|DotA apem A-BAL us/ca|NWU -sdsm|LoD -sdems6bod2|Element TD|Hero Line Wars RoC|Legion TD Mega A-BAL|Rabbits vs Sheep|LoD -sds6bod2|WoW Arena Allstars|Survival|Burbenog TD|Risk Devoultion|Tech Wars BC|Tom and Jerry|DotA apem euro|DotA apem A-BAL euro|DotA sdem euro|Legion TD Mega euro,%settingspath%,Settings,Gamenames

	IniDelete, %settingspath%, Settings, Debug
	;IniDelete, %settingspath%, Settings, UserLink
	IniDelete, %settingspath%, Settings, AntiSpam

	If (version = "1.0" || version = "1.1" || version = "1.2")
	{
		IniWrite,https://code.google.com/p/pdrmf/wiki/Preadme,%settingspath%,Settings,Readme
		IniWrite,https://code.google.com/p/pdrmf/wiki/Pchangelog,%settingspath%,Settings,Changelog
	}
}
Return

traymenu:
{
	Menu, Tray, DeleteAll
	Menu Tray, NoStandard
	Menu, Tray, add, Info, InfoTray
	Menu, Tray, add,
	Menu, Tray, add, Support, SupportTray
	Menu, Tray, add,
	Menu, Tray, add, Exit, GuIClose
	Menu, Tray, Tip, %name%
}
return

/*
checkupdate:
{
	IniRead,LastUsageDay,%settingspath%,Settings,LastUsageDay
	If (A_DD != LastUsageDay)
	{
		If (LastUsageDay = "01" || LastUsageDay = "08" || LastUsageDay = "16" || LastUsageDay = "23")
			GoSub, update
	}
	IniWrite,%A_dd%,%settingspath%,Settings,LastUsageDay
}
return
*/
/*
Update:
{ ; auto updater
Gui, 1: -alwaysontop
Gui, 2: -AlwaysOnTop
Gui, 8: +alwaysontop
	
internetCheck()
If Errorlevel
{
	MsgBox,48,Info,Your internet connection must be working.`n`nPlease connect to the internet to go on.
	return
}
Else

SplashTextOn,400,200,Update,In the following seconds the PRISM will check for updates.`nPlease be patient.

GoSub, Icons
	IfExist,%A_workingdir%\logo.ico
		Menu, Tray, icon, %A_workingdir%\logo.ico
DllCall("uxtheme\SetWindowThemeAttribute", "ptr", WinExist(), "int", 1, "int64*", 6 | 6<<32, "uint", 8)

WinSet,AlwaysonTop,Off,Update
URLdownloadToFile,http://pdrmf.googlecode.com/files/VersionCheckP.ini,%A_workingdir%\VersionCheck%A_space%PRISM.ini
	FileSetAttrib,+H,%A_workingdir%\VersionCheck%A_space%PRISM.ini,

Sleep 1000
SplashTextOff

IniRead,NewVersion,%A_workingdir%\VersionCheck%A_space%PRISM.ini,VersionCheckP,NewVersion
IniRead,NewName,%A_workingdir%\VersionCheck%A_space%PRISM.ini,VersionCheckP,NewName
IniRead,NewUrl,%A_workingdir%\VersionCheck%A_space%PRISM.ini,VersionCheckP,NewUrl

		If (Errorlevel = "1")
		{
			MsgBox,16,Info,The server seems down.
			return
		}

	If (NewVersion = "ERROR")
	{
		MsgBox,16,Info,Trying to update the program failed!`nPlease retry it in some hours.
		FileDelete,VersionCheck%A_space%PRISM.ini
		return
 	}

	If (NewVersion != "ERROR")
	{
	FileDelete,VersionCheck%A_space%PRISM.ini

		If (Newversion < version) ; might be beta but no new updates
		{
			MsgBox,64,Info,You are using the the newest version.`nSince the server isn't updated`, yet`, it seems you are using a beta version.`n`nServer: %newversion%`nPRISM: %version%
		}

		If (NewVersion = Version) ; no new
		{
			MsgBox,64,Info,You have got the latest PRISM version!
		}

		If (NewVersion != version && NewVersion > version)
		{
			soundplay,*64
			Gui, 8: font, s12 bold
			Gui, 8: Add, text, x5 y5, A new PRISM Version is available.
			Gui, 8: Add, text, x5 y28 cGreen,Click anywhere in the Window to open the project page.
			Gui, 8: show,h60 w485, New Version - %newname%
			OnMessage(0x201, "WM_LBUTTONDOWN")
		}

	} ; end check
	IniWrite,%A_DD%,%settingspath%,Settings,LastUsageDay
} ; end auto updater
return
*/

WM_LBUTTONDOWN(wParam,lParam)
{
	If A_Gui = 8
		GoSub, RunUrl
		
;	msgbox % newurl
}
Return

runurl:
Run, % newurl
return

/*
internetcheck()
{
	global
	url=www.google.com
	RunWait, ping.exe %url% -n 1,, Hide UseErrorlevel
		If ErrorLevel
		{
			If not A_IsAdmin
			{
				MsgBox,20,Information,The game announcer requires access to connect to the internet for updating.`n`nPress 'Yes' to start the GA with administrative rights or 'No' to abort the connection to the internet.`n`nAttention! If you are already logged in with administrative rights it's more likely your connection being down.
				IfMsgBox, Yes
				{
					Run *RunAs "%A_ScriptFullPath%"
					ErrorLevel := 0
					internetcheck()
				}
			}
		}
}
return
*/

icons:
{
picture = 
loadHex()

picture := Ltrim picture

	VarSetCapacity( IconData,( nSize:=StrLen(picture)//2) )
	Loop %nSize%
		NumPut( "0x" . SubStr(picture,2*A_Index-1,2), IconData, A_Index-1, "Char" )
	picture := ""       
	hICon := DllCall( "CreateIconFromResourceEx", UInt,&IconData+22
					, UInt,0, Int,1, UInt,196608, Int,32, Int,32, UInt,0 )

	;WinGet, PID, PID, A
		ID := WinExist("ahk_class" AutoHotkeyGUI) ; "ahk_pid" PID
			SendMessage, 0x80, 0, hIcon ,, ahk_id %ID%  ; Small Icon
			SendMessage, 0x80, 1, hIcon ,, ahk_id %ID%  ; Big Icon
}
return

loadHex()
{
	global
	picture = 
(join
0000010001001E1E000001002000B00E000016000000280000001E0000003C00000001002000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000007F7F7F02866B43138A6C403B93754882977B4AC7997C48E59B7E46F09D7F44F29F8044F29D7F44F29B7D45EE997C48E2967A4BC3947A4E8B927A5349967F5C1600000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000997F4C0A95795352927747A0987943D6A08243F5A88A44FFB09144FFB59745FFB79945FFB99B45FFB79945FFB49644FFAF9144FFA78A44FE9F8245F9977A47DE94794B9E947D57439F7F5F080000000000000000000000000000000000000000000000000000000000000000000000000000000087785A118E70466D977949DCA08244FEAE8F44FFB99B45FFC1A445FFC7AB44FFCAAF44FFCCB143FFCDB343FFCCB243FFCAAF44FFC7AB44FFC1A445FFB89B45FFAD8F44FFA08244FD967949D4947A52759B8D631200000000000000000000000000000000000000000000000000000000000000009075522594774B8D9A7A44E7AA8A44FDB89A44FFC4A643FFCCB042FFD0B740FFD4BD3FFFD7C03EFFD9C23EFFD9C43EFFD9C23EFFD7C03EFFD4BD3FFFD1B740FFCBB042FFC3A644FFB79944FFA68844FE997B48EE92764E88947B621F0000000000000000000000000000000000000000000000007766440F8E6E45889A7944EFAC8B44FFBC9D43FFC8AB41FFD1B63EFFD7BF3CFFDBC63BFFDFCB3BFFE1CF3BFFE2D13BFFE3D23BFFE2D13BFFE1CE3BFFDECB3BFFDBC63BFFD6BF3CFFD0B63FFFC6AB41FFBA9C43FFA98944FF977946EC8F734C8596785A11000000000000000000000000000000007F664C0A8C6B486D967443E6AA8743FFBC9B42FFC8A93FFFD1B63BFFD9C139FFDFCB39FFE4D339FFE8D93AFFEADC3AFFECDE3BFFECDF3BFFEBDE3BFFE9DC3BFFE7D93AFFE3D33AFFDECB39FFD8C23AFFD0B63BFFC6A83FFFB99942FFA58543FF947448EC93785A79A2A28B0B0000000000000000996666058E6D525D906E45DDA27D41FDB5913FFFC3A13BFFCEAF37FFD7BD35FFDFCA36FFE6D538FFEBDE3AFFEFE43BFFF0E63CFFF1E73DFFF1E83DFFF1E83DFFF0E63CFFEFE43CFFEADE3AFFE5D538FFDECA37FFD5BC36FFCBAE38FFC09F3CFFB18E3FFF9C7A41FE90724EDE998269507F7F7F0200000000856C5228896745BB96703DFFAC843BFFBB9437FFC6A333FFD0B231FFDAC132FFE3D035FFE9DC3AFFEBE140FFEAE24BFFE9E158FFE8E161FFE8E163FFE8E15DFFEAE252FFECE445FFEDE33DFFE9DC39FFE2D036FFD8C132FFCDB032FFC2A134FFB69138FFA5803BFF8F6C3EFE896C4DA7937F6B1A000000018464466689633AEE9E7537FFB18634FFBD9330FFC6A12DFFD0B12DFFDAC230FFDFCD3AFFE1D65DFFE6DC8AFFECE3B0FFF1E8C5FFF4ECCDFFF5ECCFFFF3EACAFFEEE6BCFFE9E09DFFE4DB73FFE2D74BFFE1D035FFD8C031FFCCAE2EFFC19E2EFFB78F31FFA98135FF956F37FF85633EE4876D534F866B5D13805C3AA98D6331FCA47630FFB3832CFFBC8E28FFC49B27FFCCAA2AFFD5BE4DFFE2D58EFFEFE7C4FFF5ECCCFFF4ECCEFFFAF1DDFFFDF4E3FFFDF4E3FFFCF3E1FFF7EED6FFF4ECCAFFF3ECCDFFE9E0ACFFDCCE6BFFD1B937FFC8A728FFBD9727FFB38929FFA97E2CFF9A6F30FF855E33F77E5E4087896C573D805934DE92642BFFA87629FFB37F25FFB98822FFBF9323FFCCAE53FFE5D7A9FFF3EBCEFFEFE4A3FFE8DD94FFF0E7C3FFFBF2E1FFFDF5E4FFFDF5E5FFFDF4E4FFF6EED6FFEAE2AAFFEBE192FFF3EABEFFEFE5C5FFD8C57DFFC1A133FFB78E21FFAF8222FFA77925FF9B6E29FF865D2BFE7A5838C384644C6880552BF4976526FFAA7423FFB27B1FFFB6811EFFC49F4EFFE4D5AFFFEFE2BBFFE2CC72FFDCC54FFFEADEA6FFFBF3E3FFFDF5E5FFFDF5E6FFFDF5E6FFFDF5E5FFFCF4E4FFF2EACDFFDFD06FFFDDC854FFE9D89AFFEFE4C7FFD0B97BFFB08626FFAA7A1CFFA4731FFF9B6B23FF885C26FF795430E5815C418C815223FA996420FFAA701DFFB17519FFBA8A39FFDFCBA3FFEAD7AFFFD4B158FFCEA72CFFDBC269FFF5EBD0FFFCF4E3FFFDF4E4FFFDF4E4FFFDF4E4FFFDF4E4FFFCF4E2FFFBF3E1FFE7D8A2FFCFB13CFFCAA839FFDCC589FFE9DBBDFFC3A366FFA5731CFFA06C19FF99661CFF885A20FF744C24EE744B2999814F1CFB9B621AFFAB6E18FFB3761CFFCFAD75FFEFE1C7FFD1AB63FFC4932AFFC99D31FFDEC586FFF9F0DEFFFDF4E4FFFDF4E4FFFDF4E5FFFDF4E5FFFDF4E4FFFDF4E4FFFCF4E4FFEDDFBEFFCBAA4CFFC0962DFFBE963DFFDFCBA1FFE2D1B2FFAD7F36FF9E6714FF976217FF87571AFF71461DF26C3D1999814C16FB9B6015FFAC6C13FFB37418FFD2AB71FFF1E5D0FFCFAD72FFC28F34FFC69535FFDDC188FFFBF2E1FFFDF5E8FFFDF5E7FFFDF5E7FFFDF5E7FFFDF5E7FFFDF5E7FFFDF5E8FFEDDEC0FFC6A04DFFBB8E33FFBB944AFFE0CEAEFFE4D1B2FFAC7B31FF9C6210FF955F12FF855315FF6E4116F26E411C997D4811FB9A5D10FFAB690EFFB16E0EFFBD8431FFE5CEACFFE9DBC3FFCDAA6FFFC2923DFFD4B070FFF6EBD9FFFEF7EEFFFEF7EDFFFEF7ECFFFEF7EDFFFEF7EDFFFEF7EDFFFDF6EDFFE2CDA8FFBF9346FFBD9650FFD7C29EFFECDECBFFC49F6AFFA06613FF9A5F0CFF925A0EFF814E10FF6B3E11F2754B2B917A430EFA96590CFFAA680EFFB27113FFBD812CFFD0A569FFEAD9BEFFEBDECAFFD3B688FFCAA264FFE5D1B1FFFBF7F0FFFDF9F3FFFEF9F2FFFEF9F2FFFEF9F2FFFDF8F2FFF3E9DAFFCFB07DFFC4A26AFFDDCCAFFFEDE3D2FFD3B78FFFB48542FFA46C1DFF9A600EFF90570CFF7C490CFF673A11F079513371753F0DF692550DFFAB6B14FFB87A23FFC58F44FFC8954CFFD3AB71FFEAD7BBFFF3EDE3FFE1D0B7FFDAC4A4FFECE1D0FFFBF8F2FFFEFAF5FFFEFAF5FFFDFAF5FFF5EEE5FFDFCFB6FFD6C2A2FFEAE1D2FFF0E6D8FFD5BA91FFBD9153FFB88B4BFFAE7C36FF9E6719FF915A11FF78450BFF683B16E67B563C44744217E5905716FFAC7020FFBE8638FFCC9D5AFFCD9E5AFFCC9B55FFD0A567FFE1C7A2FFF0E4D3FFF2EBE1FFF3EDE5FFFBF8F5FFFDFBF9FFFEFBF9FFFDFBF9FFF7F3EEFFF0EAE0FFF1E9DEFFE5D5BBFFCFAE7FFFBF9356FFBD9153FFBE945AFFB78C4FFFA37029FF925F1DFF774714FF693F1EC87F583A1A7A4D28BB8D5A24FEAB742CFFC2914CFFD1A86DFFD2A76AFFD0A362FFCE9F5CFFCEA15FFFD6B079FFE1C59FFFECDAC2FFF2E6D8FFF5ECE2FFF6EDE4FFF3EADEFFEEE0CEFFE3CEB0FFD5B68AFFC8A068FFC29659FFC2975CFFC39A62FFC49F6AFFBF9963FFA87939FF936329FF784C21F9704A2D93999999058862447F8C6034F7A77538FFC3975BFFD5B17EFFD7B17CFFD4AC73FFD2A86BFFD1A566FFD0A363FFD0A363FFD2A76BFFD4AC74FFD5AF7AFFD5B07BFFD3AD77FFCFA76EFFCBA165FFC99E61FFC89E63FFC89F66FFC8A26CFFC9A674FFCBAB7DFFC5A475FFAA7F48FF916635FF7C5534E87B5A42550000000095765C3A8F6746CEA07443FFBF9763FFD7B88DFFDCBC8FFFDAB787FFD7B27EFFD5AE76FFD4AB71FFD3A96DFFD3A86CFFD2A76CFFD1A76CFFD1A66CFFD0A66BFFCFA56BFFCEA56CFFCDA56DFFCDA771FFCEAA77FFCFAD7FFFD1B288FFD2B68FFFC7A980FFA78052FF8D6842FF87664CB59273642100000000A28B730B97765B7B9C7552F4B58F64FFD5B994FFE0C6A1FFDFC49CFFDDBF94FFDBBA8BFFD9B583FFD7B27EFFD7B17AFFD6AF78FFD5AE77FFD4AD77FFD4AD77FFD3AD78FFD3AE7AFFD3AF7EFFD3B284FFD5B78CFFD7BB95FFD8C09DFFD7C0A0FFC3A682FFA17E58FE8E6F53E390766258AAAAAA0300000000000000009F876F209E7D63A6AB8766F9CBAF8FFFE1CCB1FFE4CEB0FFE4CCABFFE2C8A3FFE0C49CFFDEC095FFDDBD90FFDCBB8CFFDBB98BFFDAB98AFFDAB98BFFDABA8CFFDBBC91FFDBBE96FFDCC29CFFDEC6A5FFDFCAACFFDECBB0FFD7C2A8FFB79B7BFF9C7E61F4957A66878975620D000000000000000000000000FF000001A38D7638A88A71BAB99D81FAD8C3ABFFE5D4BEFFE8D6BDFFE8D5BAFFE7D3B5FFE6CFB0FFE5CDACFFE4CBA8FFE3CAA7FFE3C9A6FFE3C9A7FFE3CAA8FFE4CCACFFE4CEB0FFE4D1B6FFE5D3BAFFE4D4BEFFDFCFBBFFC8B39BFFAB8F75F3A0866F9CA28B8321000000000000000000000000000000000000000000000000AB948143B09780B6C3AC95F9DCCCBAFFE9DBC9FFECDECAFFECDDC8FFECDCC5FFECDBC3FFECDAC1FFEBD9C0FFEBD8C0FFEBD9C0FFEBD9C1FFEBDAC3FFEADBC6FFEADCC9FFE9DCCAFFE4D6C6FFD0BFACFEB59E88F4AB927F9EAB958A2E0000000000000000000000000000000000000000000000000000000000000000B49B8C33B79F8CA1C8B4A2EFDCCDBFFFEADFD2FFEEE3D5FFEFE4D5FFF0E4D4FFF0E4D3FFF0E3D3FFEFE3D3FFEFE3D3FFEFE3D3FFEFE3D4FFEEE3D5FFECE2D5FFE5DACDFFD2C3B4FFBEA999E6B29C8B89B19A922100000000000000000000000000000000000000000000000000000000000000000000000000000001BCAA971BBCAA996CC9B5A7C3D6C7BBF1E3D8CDFDEBE2D8FFEFE7DCFFF1E8DEFFF1E9DEFFF1E9DEFFF0E8DEFFEFE7DDFFEEE5DBFFE8DFD5FFDED2C7FBCFC0B3EBC2B0A2B5B8A89A5BB6A3910E000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000D4AAAA06C7B1A62ECAB7A96BD1C2B5AED9CCC0D8E0D4CAF0E5DAD1F7E6DDD5FBE7DED6FBE6DDD4FAE3D9CFF5DCD0C6EBD4C6BBD1CCBCAFA1C4B1A65CC4AEA723AAAAAA0300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000C9BBAE13CEBDB32FCEBFB354D3C4B976D5C7BD93D3C6BC99D4C7BE8BD2C4B86DCDC0B24DCDC0B429CCBBAA0F000000000000000000000000000000000000000000000000000000000000000000000000FFC007FCFF0001FCFE0000FCF800003CF000001CF000001CE000000CC0000004C00000048000000080000000800000000000000000000000000000000000000000000000800000008000000080000000C0000004C0000004E000000CE000000CF000001CF800003CFC00007CFF0001FCFFC007FCFFFC7FFC
)
WriteFile(A_workingdir "\logo.ico",picture)
}
return

WriteFile(file,data)
{
   Handle :=  DllCall("CreateFile","str",file,"Uint",0x40000000
                  ,"Uint",0,"UInt",0,"UInt",4,"Uint",0,"UInt",0)
   Loop
   { 
     if strlen(data) = 0
        break
     StringLeft, Hex, data, 2         
     StringTrimLeft, data, data, 2  
     Hex = 0x%Hex%
     DllCall("WriteFile","UInt", Handle,"UChar *", Hex
     ,"UInt",1,"UInt *",UnusedVariable,"UInt",0) 
    } 
  
   DllCall("CloseHandle", "Uint", Handle)
   return
}

/*
###############################################################################################################
###                                       HTTPRequest. Version: 2.49                                        ###
###############################################################################################################

HTTPRequest. Copyright Â© 2011-2012 [VxE]. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that
the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this list of conditions and the
following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the
following disclaimer in the documentation and/or other materials provided with the distribution.

3. The name "[VxE]" may not be used to endorse or promote products derived from this software without specific
prior written permission.

THIS SOFTWARE IS PROVIDED BY [VxE] "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
SHALL [VxE] BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
THE POSSIBILITY OF SUCH DAMAGE.
*/

HTTPRequest( URL, byref In_POST__Out_Data="", byref In_Out_HEADERS="", Options="" ) { ; -----------------------
; Function by [VxE], compatible with AHK v1.0.48.05 (basic), v1.1.00.00 (AHK-L ANSI, Unicode, x64) and later.
; Special thanks to derRaphael and everyone who reported bugs and/or suggested improvements.
; Source is freely available at: http://www.autohotkey.com/forum/viewtopic.php?t=73040
; Submits one request to the specified URL with optional POST data and custom headers. Upon success, returns
; the number of bytes downloaded OR the number of characters in the response. Otherwise, returns zero and a
; description of the error is placed in 'In_Out_HEADERS'. The response body and headers are placed into
; 'In_POST__Out_Data' and 'In_Out_HEADERS' respectively, and text data is converted from the codepage stated in
; the header to the script's ANSI codepage OR to UTF-16 for unicode versions of AHK.
; "ErrorLevel" is set to '0' if there is a problem, otherwise it is set to the HTTP response code (e.g: 404).

	Static version := "2.49", Ptr, W_A, PtrSize := 0, DW := "UInt", IsUnicode, MyACP, MyCharset, Default_Agent
	, sws := "`t`n`r ", swp := "There was a problem ", sel := ", ErrorLevel = ", sle := ", A_LastError = "
; The default accept types are geared towards webservice response streams, which tend to be XML.
	, Default_Accept_Types := "text/xml, text/json; q=0.4, text/html; q=0.3, text/*; q=0.2, */*; q=0.1"
; If you prefer, the following accept types are what firefox wants when it requests a web page.
;	, Default_Accept_Types := "text/html, application/xhtml+xml, application/xml; q=0.9, */*; q=0.8"
; This list of content subtypes is not official, I just globbed together a few MIME subtypes to use as a
; whitelist for converting downloaded text to the script's codepage. If the Content-Type response header IS
; "text/..." OR one of these subtypes follows the "/", then the data is treated as text. Otherwise, the data
; is treated as binary and the user must deal with it as binary.
	, Text_Content_Subtypes := "/atom/html/json/rss/soap/xhtml/xml/x-www-form-urlencoded"
; The list of internet flags and values has been condensed and obfuscated for version (09-10-2011).
; Flag values may be found here > http://msdn.microsoft.com/en-us/library/aa383661%28v=vs.85%29.aspx
	, internet_flags_list := "
( LTRIM JOIN|INTERNET_FLAG_
	....
	NEED_FILE
	MUST_CACHE_REQUEST|.
	FWD_BACK|.
	FORMS_SUBMIT|..
	PRAGMA_NOCACHE|.
	NO_UI|.
	HYPERLINK|.
	RESYNCHRONIZE|.
	IGNORE_CERT_CN_INVALID|.
	IGNORE_CERT_DATE_INVALID|.
	IGNORE_REDIRECT_TO_HTTPS|.
	IGNORE_REDIRECT_TO_HTTP|..
	RESTRICTED_ZONE|.
	NO_AUTH|.
	NO_COOKIES|.
	READ_PREFETCH|.
	NO_AUTO_REDIRECT|.
	KEEP_CONNECTION|.
	SECURE|.
	FROM_CACHE
	OFFLINE|.
	MAKE_PERSISTENT|.
	DONT_CACHE|...
	NO_CACHE_WRITE|.
	RAW_DATA|.
	RELOAD|
)"
; Update (12-10-2011): The list of security flags and values is condensed and obfuscated.
; Flag values may be found here > http://msdn.microsoft.com/en-us/library/aa385328%28v=VS.85%29.aspx
	, security_flags_list := "
( LTRIM JOIN|SECURITY_FLAG_
	~
	SECURE|.
	SSL|.
	SSL3|.
	PCT|.
	PCT4|.
	IETFSSL4|..
	IGNORE_REVOCATION|.
	IGNORE_UNKNOWN_CA|.
	IGNORE_WRONG_USAGE|...
	IGNORE_CERT_CN_INVALID|.
	IGNORE_CERT_DATE_INVALID|.
	IGNORE_REDIRECT_TO_HTTPS|.
	IGNORE_REDIRECT_TO_HTTP|............
	FORTEZZA|.
	40BIT
	NORMALBITNESS
	STRENGTH_WEAK|.
	128BIT
	STRENGTH_STRONG|.
	56BIT
	STRENGTH_MEDIUM|.
	UNKNOWNBIT|
)"
	, Codepage_Charsets := "|
; Codepage list taken from here (7-2011) > http://msdn.microsoft.com/en-us/library/dd317756%28v=vs.85%29.aspx
( LTRIM JOIN|
	00037=IBM037|00437=IBM437|00500=IBM500|00708=ASMO-708|00720=DOS-720|00737=ibm737|00775=ibm775|00850=ibm850
	00852=ibm852|00855=IBM855|00857=ibm857|00858=IBM00858|00860=IBM860|00861=ibm861|00862=DOS-862|00863=IBM863
	00864=IBM864|00865=IBM865|00866=cp866|00869=ibm869|00870=IBM870|00874=windows-874|00875=cp875
	00932=shift_jis|00936=gb2312|00949=ks_c_5601-1987|00950=big5|01026=IBM1026|01047=IBM01047|01140=IBM01140
	01141=IBM01141|01142=IBM01142|01143=IBM01143|01144=IBM01144|01145=IBM01145|01146=IBM01146|01147=IBM01147
	01148=IBM01148|01149=IBM01149|01200=utf-16|01201=unicodeFFFE|01250=windows-1250|01251=windows-1251
	01252=Windows-1252|01253=windows-1253|01254=windows-1254|01255=windows-1255|01256=windows-1256
	01257=windows-1257|01258=windows-1258|01361=Johab|10000=macintosh|10001=x-mac-japanese
	10002=x-mac-chinesetrad|10003=x-mac-korean|10004=x-mac-arabic|10005=x-mac-hebrew|10006=x-mac-greek
	10007=x-mac-cyrillic|10008=x-mac-chinesesimp|10010=x-mac-romanian|10017=x-mac-ukrainian|10021=x-mac-thai
	10029=x-mac-ce|10079=x-mac-icelandic|10081=x-mac-turkish|10082=x-mac-croatian|12000=utf-32|12001=utf-32BE
	20000=x-Chinese-CNS|20001=x-cp20001|20002=x-Chinese-Eten|20003=x-cp20003|20004=x-cp20004|20005=x-cp20005
	20105=x-IA5|20106=x-IA5-German|20107=x-IA5-Swedish|20108=x-IA5-Norwegian|20127=us-ascii|20261=x-cp20261
	20269=x-cp20269|20273=IBM273|20277=IBM277|20278=IBM278|20280=IBM280|20284=IBM284|20285=IBM285|20290=IBM290
	20297=IBM297|20420=IBM420|20423=IBM423|20424=IBM424|20833=x-EBCDIC-KoreanExtended|20838=IBM-Thai
	20866=koi8-r|20871=IBM871|20880=IBM880|20905=IBM905|20924=IBM00924|20932=EUC-JP|20936=x-cp20936
	20949=x-cp20949|21025=cp1025|21866=koi8-u|28591=iso-8859-1|28592=iso-8859-2|28593=iso-8859-3|28594=iso-8859-4
	28595=iso-8859-5|28596=iso-8859-6|28597=iso-8859-7|28598=iso-8859-8|28599=iso-8859-9|28603=iso-8859-13
	28605=iso-8859-15|29001=x-Europa|38598=iso-8859-8-i|50220=iso-2022-jp|50221=csISO2022JP|50222=iso-2022-jp
	50225=iso-2022-kr|50227=x-cp50227|51932=euc-jp|51936=EUC-CN|51949=euc-kr|52936=hz-gb-2312|54936=GB18030
	57002=x-iscii-de|57003=x-iscii-be|57004=x-iscii-ta|57005=x-iscii-te|57006=x-iscii-as|57007=x-iscii-or
	57008=x-iscii-ka|57009=x-iscii-ma|57010=x-iscii-gu|57011=x-iscii-pa|65000=utf-7|65001=utf-8|
)"

; Step 1: Initialize variables, first the static variables for unknown constants.
	If !( PtrSize )
	{
		If ( "" = PtrSize := A_PtrSize ) ; Check for 64 bit environment and pointer type.
			PtrSize := 4, Ptr := DW
		Else Ptr := "Ptr"
		If !( IsUnicode := 1 = A_IsUnicode ) ; Check for unicode (wide char) environment
		; GetACP > http://msdn.microsoft.com/en-us/library/ms905215.aspx
			W_A := "A", MyACP := SubStr( 100000.0 + DllCall("GetACP"), 2, 5 )
		; There is no error check on GetACP because it's extraordinarily unlikely to fail.
		Else W_A := "W", MyACP := "01200" ; UTF-16
		; Detect the active codepage and look up the charset identifier for it (default = UTF-8)
		MyCharset := ( 7 = pos := 7 + InStr( Codepage_Charsets, "|" MyACP "=" ) ) ? "UTF-8"
		: SubStr( Codepage_Charsets, pos, InStr( Codepage_Charsets, "|", 0, pos ) - pos )
		SplitPath, A_ScriptName,,,, Default_Agent
		Default_Agent .= "/1.0 (Language=AutoHotkey/" A_AhkVersion "; Platform=" A_OSVersion ")"
	}

; Initialize local variables
	Internet_Open_Type := 1 ; INTERNET_OPEN_TYPE_DIRECT = 1 ; _PRECONFIG = 0 ; _PROXY = 3
	Security_Flags := Security_Flags_Add := Security_Flags_Nix := 0
	Response_Code := "0" ; despite being digits, always treat the response code as a string.
	Do_Callback := 0
	Do_NonBinary_Up := 0
	Do_Binary_Down := 0
	Do_Up_MD5_Hash := 0
	Do_File_Upload := 0
	Do_Multipart := 0
	Do_Download_To_File := 0
	Do_Download_Resume := 0
	Do_Legacy_Dual_Output := 0 ; deprecated in v2.46+
	Agent := Default_Agent
	Accept_Types := Default_Accept_Types
	Expected_Type := "text/plain; charset=utf-8"
	Multipart_Boundary := ""
	proxy_bypass := ""
	Method_Verb := ""
	MyErrors := ""
	dbuffsz := 0
	port := 0
	dtsz := 0
	hWinINet := hInternet := hConnection := hRequest := hProv := hHash := 0 ; init these as null handles
	Convert_POST_To_Codepage := MyACP

; Initialize typical flags for a normal request. These can be modified with the 'Options' parameter.
	Internet_Flags := 0
	| 0x400000 ; INTERNET_FLAG_KEEP_CONNECTION
	| 0x80000000 ; INTERNET_FLAG_RELOAD
	| 0x20000000 ; INTERNET_FLAG_NO_CACHE_WRITE

	StringLen, Content_Length, In_POST__Out_Data ; get the auto-content-length. this may get overwritten.
	Content_Length <<= IsUnicode

; Step 2: Crack the url into its components. WinINet\InternetCrackURL limits the url to about 2060
; characters, which is unacceptable, especially for a function designed to service web APIs.

	hbuffer := swp "parsing the URL: """ URL """`n" ; pre-generate the bad-url error

; Crack the scheme (setting it to 'http' if omitted, allowing a url like "www.***.com")
	If ( pos := InStr( URL, "://" ) )
	{
		StringLeft, scheme, URL, pos - 1
		StringLower, scheme, scheme
		StringTrimLeft, URL, URL, pos + 2
		If ( scheme = "https" ) ; Connect using SSL. Add the following internet flags:
			Internet_Flags |= 0x1000 ; INTERNET_FLAG_IGNORE_CERT_CN_INVALID
						| 0x2000   ; INTERNET_FLAG_IGNORE_CERT_DATE_INVALID
						| 0x800000 ; INTERNET_FLAG_SECURE ; Technically, this is redundant for https
		Else If ( scheme != "http" )
			MyErrors .= swp "parsing the URL: HTTPRequest does not support '" scheme "' type connections.`n"
	}
	Else scheme := "http"

; Crack the path and query (leave them joined as one string because that's how HttpOpenRequest accepts them).
	StringLeft, host, URL, pos := InStr( URL "/", "/" ) - 1
	StringTrimLeft, URL, URL, pos

; Crack the username and password from the host (if present).
	If ( pos := InStr( host, "@" ) )
	{
		StringLeft, user, host, pos - 1
		StringTrimLeft, host, host, pos
		If ( pos := InStr( user, ":" ) )
		{
			StringTrimLeft, pass, user, pos
			StringLeft, user, user, pos - 1
		}
		Else pass := ""
	}
	Else user := pass := ""

; Crack the port from the host. If the host looks like a bracketed IP literal, look for the colon
; to the right of the close-bracket. Default port is 80 for HTTP and 443 for HTTPS
	If ( pos := InStr( host, ":", 0, InStr( host, "[" ) = 1 ? InStr( host, "]" ) + 1 : 1 ) )
	&& ( 0 < port := 0 | SubStr( host, pos + 1 ) ) && ( port < 65536 )
	{
		StringTrimLeft, port, host, pos
		StringLeft, host, host, pos - 1
	}
	Else port := scheme = "https" ? 443 : 80

; Return error if the host is blank (don't check for other format errors).
	If ( host = "" )
		MyErrors .= hbuffer

; Step 3: Parse the request headers so we can copy them to an internal buffer, make them pretty, and
; handle special headers (like acceptable mime types, user agent and content specs).
	StringLen, pos, In_Out_HEADERS
	VarSetCapacity( hbuffer, 1 + pos << IsUnicode )
	hbuffer := "`r`n"
	Loop, Parse, In_Out_HEADERS, `n
	{
		pos := InStr( A_LoopField ":", ":" )
		rbuffer := SubStr( A_LoopField, 1, pos - 1 ) "`n" SubStr( A_LoopField, pos + 1 )
		Loop, Parse, rbuffer, `n, %sws%
			If ( A_Index = 1 )
				rbuffer := A_LoopField
			Else If ( A_LoopField = "" )
			{
				If ( rbuffer != "Content-MD5" )
					Continue
				Else If !( Do_Up_MD5_Hash := DllCall( "LoadLibrary" W_A, "Str", "Advapi32.dll" ) )
					MyErrors .= swp "loading Advapi32.dll to calculate the Content-MD5 header. 'LoadLibrary" W_A "' failed" sel ErrorLevel sle A_LastError "`n"
			; CryptAcquireContext > http://msdn.microsoft.com/en-us/library/aa379886%28v=vs.85%29.aspx
				Else If !DllCall( "Advapi32\CryptAcquireContext" W_A, Ptr "*", hProv := 0, Ptr, 0, Ptr, 0, DW, 1, DW, 0xF0000000 )
					MyErrors .= swp "acquiring the key container to calculate the Content-MD5 header. 'CryptAcquireContext' failed" sel ErrorLevel sle A_LastError "`n"
			; CryptCreateHash > http://msdn.microsoft.com/en-us/library/aa379908%28v=vs.85%29.aspx
				Else If !DllCall( "Advapi32\CryptCreateHash", Ptr, hProv, DW, 0x8003, Ptr, 0, DW, 0, Ptr "*", hHash := 0 )
					MyErrors .= swp "creating the hash object to calculate the Content-MD5 header. 'CryptCreateHash' failed" sel ErrorLevel sle A_LastError "`n"
			; NOTE: If the user wants an auto-Content-MD5, but there is a problem, abort the entire request.
			}
			Else If ( rbuffer = "Accept" )
				Accept_Types := A_LoopField
			Else If ( rbuffer = "Content-Length" ) && ( 0 < 1 | A_LoopField )
				Content_Length := A_LoopField
			Else If ( rbuffer = "Content-Type" )
			{
				hbuffer .= "Content-Type: " A_LoopField "`r`n"
				StringReplace, Multipart_Boundary, A_LoopField, % ",", % ";", A
				If ( 7 != pos := 7 + InStr( Multipart_Boundary, "charset=" ) )
				&& ( pos := InStr( Codepage_Charsets, SubStr( Multipart_Boundary, pos
					, InStr( Multipart_Boundary ";" , ";", 0, pos ) - pos ) "|" ) )
					StringMid, Convert_POST_To_Codepage, Codepage_Charsets, pos - 5, 5

				; NOT YET IMPLEMENTED: detect multipart content and determine the boundary
				Multipart_Boundary := ( InStr( A_LoopField, "Multipart/" ) != 1
					|| 9 = pos := 9 + InStr( Multipart_Boundary, "boundary=" ) ) ? ""
				: SubStr( Multipart_Boundary, pos, InStr( Multipart_Boundary ";", ";" ) - pos )
			}
			Else If ( rbuffer = "Referrer" )
				hbuffer .= "Referer: " A_LoopField "`r`n"
			Else If ( rbuffer = "User-Agent" )
				Agent := A_LoopField
			Else hbuffer .= rbuffer ": " A_LoopField "`r`n"
	}
; Automatically add the 'no cookies' flag if the user specified a custom cookie. The flag actually tells
; wininet not to automatically handle cookies (which 'automatically' ignores custom cookie headers).
	IfInString, hbuffer, % "`r`nCookie: "
		options .= "`n+NO_COOKIES"

; Step 4: Extract the multipart envelope from the options parameter, then parse the options normally.
	If ( 4 < dtsz := 4 + StrLen( Multipart_Boundary ) ) && ( pos := InStr( options, "--" Multipart_Boundary ) )
	&& ( ( dtsz + 0 ) != ( dtsz += InStr( options, "--" Multipart_Boundary "--", 0, 0 ) ) )
	{
		StringMid, Multipart_Envelope, options, pos, dtsz - pos
		options := SubStr( options, 1, pos - 1 ) SubStr( options, dtsz )
;		Do_Multipart := 1 ; NOT YET IMPLEMENTED
	}
	Loop, Parse, options, `n
	{
		If InStr( A_LoopField, ">" ) + 3 >> 2 = 1
		{
		; Handle the legacy output-file syntax
			Loop, Parse, A_LoopField, >, %sws%
				If ( A_Index = 1 )
					options := ( InStr( A_LoopField, "R" ) ? "RESUME`n" : "SAVEAS`n" )
					;, Do_Legacy_Dual_Output := !!InStr( A_LoopField, "N" )
				Else options .= A_LoopField
		}	
		Else
		{
			 If ( ( pos := InStr( A_LoopField, ":" ) ) && ( pos < InStr( A_LoopField ":\", ":\" ) ) )
			|| ( pos := InStr( A_LoopField, "=" ) )
			|| ( pos := InStr( A_LoopField, " ", 0, 1 + InStr( A_LoopField, " BYPASS" ) ) )
			|| ( pos := 1 + StrLen( A_LoopField ) )
			options := SubStr( A_LoopField, 1, pos - 1 ) "`n" SubStr( A_LoopField, pos + 1 )
		}

		Loop, Parse, options, `n, %sws%
			If ( A_Index = 1 )
				StringUpper, options, A_LoopField
		; AutoProxy option: use IE's proxy configuration
			Else If ( options = "AUTOPROXY" )
				Internet_Open_Type := !!A_LoopField || A_LoopField = "" ? 0 : 1
		; Binary option: do not attempt to convert downloaded data to the script's codepage.
			Else If ( options = "BINARY" )
				Do_Binary_Down := !!A_LoopField || A_LoopField = ""
		; Callback option: inform a function in the script about the transaction progress
			Else If ( options = "CALLBACK" )
			{
				If ( pos := InStr( A_LoopField, "," ) ) || ( pos := InStr( A_LoopField, ";" ) )
				|| ( pos := InStr( A_LoopField, "`t" ) ) || ( pos := InStr( A_LoopField, " " ) )
				{
					Do_Callback_Func := SubStr( A_LoopField, 1, pos - 1 ) "`n" SubStr( A_LoopField, pos + 1 )
					Loop, Parse, Do_Callback_Func, `n, %sws%
						If ( A_Index = 1 )
							Do_Callback_Func := A_LoopField
						Else Do_Callback_3rdParam := A_LoopField
				}
				Else Do_Callback_Func := A_LoopField
				Do_Callback := IsFunc( Do_Callback_Func ) + 3 >> 2 = 1 ; OK if 1, 2, 3, or 4
				cfc := "The callback function """ Do_Callback_Func """ returned 'CANCEL' to cancel the transaction. "
			}
		; Charset option: convert POST text's codepage before uploading it
			Else If ( options = "CHARSET" )
				Do_NonBinary_Up := !( pos := InStr( Codepage_Charsets, "=" A_LoopField "|" ) ) ? Convert_POST_To_Codepage
				: SubStr( Codepage_Charsets, pos - 5, 5 )
		; CheckMD5 option: deprecated. The Advapi32-based MD5 calc happens in-line with the data download
; NOTE: the MD5 will be still be checked (as "Computed-MD5") if "Content-MD5" is in the response headers.
;			Else If ( options = "CHECKMD5" ) || ( options = "CHECK MD5" )
;				Do_Dn_MD5_Hash := 1
		; Codepage option: convert POST text's codepage before uploading it
			Else If ( options = "CODEPAGE" )
				Do_NonBinary_Up := ( A_LoopField | 0 < 1 || A_LoopField >> 16 ) ? Convert_POST_To_Codepage
				: ( Convert_POST_To_Codepage := SubStr( A_LoopField + 100000.0, 2, 5 ) )
		; Expect option: declare the expected response content type. This only comes into play if the response
		; headers don't contain the 'Content-Type' header, or if text-type response doesn't have the 'charset'
			Else If ( options = "EXPECT" )
			{
				If InStr( A_LoopField, "charset=" ) = 1
					Expected_Type := SubStr( Expected_Type, 1, InStr( Expected_Type, "charset" ) - 1 ) A_LoopField
				Else Expected_Type := A_LoopField
			}
		; Flags option: add or remove flags
			Else If InStr( options, "+" ) = 1 || InStr( options, "-" ) = 1
			{
			; When handling flag options, first determine whether the flag is being added or removed.
				StringLeft, flag_plus_or_minus, options, 1

			; For backwards compatibility, support the "+FLAG: <flag id>" syntax.
				If ( options = "+FLAG" ) || ( options = "-FLAG" )
					Loop, Parse, A_LoopField, `n, %sws%+-_
						StringUpper, options, A_LoopField
				Else
					Loop, Parse, options, `n, %sws%+-_ ; trim whitespace and +, -, and _
						StringUpper, options, A_LoopField

			; Determine whether the flag is a security flag or a regular flag and get its value
				If ( pos := InStr( internet_flags_list, "|" options "|" ) )
				|| ( pos := InStr( internet_flags_list, "|INTERNET_FLAG_" options "|" ) )
				{
					StringLeft, options, internet_flags_list, pos
					StringReplace, options, options, ., ., UseErrorLevel
					If ( flag_plus_or_minus = "+" )
						Internet_Flags |= 1 << ErrorLevel
					Else Internet_Flags &= ~( 1 << ErrorLevel )
				}
			; Look in the security flags for one with this name (or this short name)
				Else If ( pos := InStr( security_flags_list, "|" options "|" ) )
					|| ( pos := InStr( security_flags_list, "|SECURITY_FLAG_" options "|" ) )
				{
					StringLeft, options, security_flags_list, pos
					StringReplace, options, options, ., ., UseErrorLevel
					If ( flag_plus_or_minus = "+" )
						Security_Flags_Add |= 1 << ErrorLevel
					Else Security_Flags_Nix |= 1 << ErrorLevel
				}
			; If the first letter is an 'S', and the rest is an INT power of 2, it's a security flag
				Else If ( InStr( options, "S" ) = 1 ) && ( 0 < pos := Abs( SubStr( options, 2 ) ) )
					&& ( pos = 1 << Round( Ln( pos ) / Ln(2) ) )
				{
					If ( flag_plus_or_minus = "+" )
						Security_Flags_Add |= pos
					Else Security_Flags_Nix |= pos
				}
			; If it is an INT power of 2, treat it as an internet flag
				Else If ( 0 < pos := Abs( options ) ) && ( pos = 1 << Round( Ln( pos ) / Ln(2) ) )
					If ( flag_plus_or_minus = "+" )
						Internet_Flags |= pos
					Else Internet_Flags &= ~pos
			}
		; Method option: use a different verb when creating the request
			Else If ( options = "METHOD" ) && InStr( "|GET|HEAD|POST|PUT|DELETE|OPTIONS|TRACE|", "|" A_LoopField "|" )
				StringUpper, Method_Verb, A_LoopField
		; Proxy option: use the indicated URL as the proxy server for this request.
			Else If ( options = "PROXY" )
				Internet_Open_Type := 3, proxy_url := A_LoopField
		; Proxy Bypass option: the URL should not beaccessed through the proxy.
			Else If ( options = "PROXY BYPASS" ) || ( options = "BYPASS" )
				proxy_bypass .= A_LoopField "`r`n"
		; Resume OR SaveAs options: download the data to the hard drive and NOT to memory
			Else If ( options = "RESUME" ) || ( options = "SAVEAS" ) || ( options = "SAVE AS" )
			{
				Do_Download_To_File := 1
				file_ext := FileExist( output_file_path := A_LoopField )
				If ( file_ext = "" )
				{
				; The file does not exist, so make sure the folder it belong to DOES exist
					If ( pos := InStr( output_file_path, "\", 0, 0 ) )
					&& ! FileExist( SubStr( output_file_path, 1, pos - 1 ) )
						MyErrors .= "The file path """ output_file_path """ is not valid. The folder can't be found.`n"
				}
				Else If InStr( file_ext, "D" )
				{
				; The user only gave us a path to a folder. We'll have to figure out the filename from the url
					file_ext := "V://x/E/" url
					SplitPath, file_ext, file_ext
					StringLeft, file_ext, file_ext, InStr( file_ext "?", "?" ) - 1
					output_file_path .= ( SubStr( output_file_path, 0 ) = "\" ? "" : "\" )
					. ( file_ext = "" ? "HTTPRequest " A_Year "-" A_MM "-" A_DD "_" SubStr( A_Now A_MSec, 9 ) ".txt" : file_ext )
				}
				Else If ( options = "RESUME" )
				{
				; The file exists, so the path is OK. Check if the user wants to resume a download.
					FileGetSize, Do_Download_Resume, % output_file_path
					hbuffer .= "Range: bytes=" Do_Download_Resume "-`r`n"
				}
			}
		; Upload option: use a file on the disk as the data source for the file upload.
			Else If ( options = "UPLOAD" ) && !( Do_File_Upload ) ; ignore 'extra' upload options
			{
			; Update (2-28-2012, v2.45) change how the upload file is handled. Upon resolving the option,
			; attempt to open the file with GENERIC_READ permission (0x80000000) and receive a handle to it.
			; If that is successful, then get its size. This is meant to streamline the upload process and
			; is necessary for the overhauled Content-MD5.
				Loop, % A_LoopField, 0, 0
				{
					Upload_File_Path := A_LoopFileFullPath ; the file loop verifies that the target is a FILE
				; CreateFile > http://msdn.microsoft.com/en-us/library/aa363858%28v=vs.85%29.aspx
					If !( Do_File_Upload := DllCall( "CreateFile" W_A, Ptr, &Upload_File_Path, DW, 0x80000000, DW, 0, Ptr, 0, DW, 4, DW, 0, Ptr, 0, Ptr ) )
						MyErrors .= swp "opening the file to upload """ Upload_File_Path """. 'CreateFile" W_A "' failed" sel ErrorLevel sle A_LastError "`n"
				; GetFileSizeEx > http://msdn.microsoft.com/en-us/library/aa364957%28v=vs.85%29.aspx
					Else If !DllCall( "GetFileSizeEx", Ptr, Do_File_Upload, "Int64*", Content_Length )
						MyErrors .= swp "determining the size of the file to upload """ Upload_File_Path """. 'GetFileSizeEx' failed" sel ErrorLevel sle A_LastError "`n"
					Break
				}
			}
	}
	StringTrimRight, proxy_bypass, proxy_bypass, 2 ; chop trailing CRLF

; Step 5: copy the POST data from the input variable to a local buffer. This is to protect the data
; from being altered or released during the upload (which may take a while). Also check whether
; the user wants to change the character encoding of text-type data (e.g: from UTF-16 to UTF-8).
; Also, even if we're uploading from a file, 'dbuffsz' must be the number of bytes in the data.
	If ( 0 < Content_Length ) && ( MyErrors = "" )
	{
		If ( Do_File_Upload )
		{
		; If we're doing a file upload, do NOT copy the files contents to a buffer yet. DO make
		; sure the content-type header is present.
			VarSetCapacity( dbuffer, 4096, 0 )
			dbuffsz := Content_Length := SubStr( Content_Length + 0.0, 1, 1 + FLOOR( LOG( Content_Length )))
			hbuffer .= "Content-Length: " Content_Length "`r`n"
			SplitPath, Upload_File_Path,,, file_ext ; Only use the upload file's ext for the auto-type.
			If !InStr( hbuffer, "`r`nContent-Type: " )
				hbuffer .= "Content-Type: " ( file_ext = "xml" ? "text/xml"
					: file_ext = "txt" ? "application/x-www-form-urlencoded"
					: "application/octet-stream" ) "`r`n"
		}
		Else If !( Do_NonBinary_Up ) || ( Do_NonBinary_Up = MyACP ) || ( Do_Multipart )
		{
		; Either the POST is binary data or is already in the desired encoding, so just copy it.
			VarSetCapacity( dbuffer, dbuffsz := Content_Length, 0 )
			DllCall( "RtlMoveMemory", Ptr, &dbuffer, Ptr, &In_POST__Out_Data, DW, Content_Length )
			Content_Length := SubStr( Content_Length + 0.0, 1, 1 + FLOOR( LOG( Content_Length )))
			hbuffer .= "Content-Length: " Content_Length "`r`n"
			IfNotInString, hbuffer, % "`r`nContent-Type: "
				hbuffer .= "Content-Type: " ( InStr( dbuffer, "<?xml" ) + 3 >> 2 = 1 ? "text/xml"
					: "application/x-www-form-urlencoded" ) "; charset=" MyCharset "`r`n"
		}
		Else
		{
		; Change the character encoding while copying the POST data into the local buffer.
			IfNotInString, hbuffer, % "`r`nContent-Type: "
			{
				hbuffer .= "Content-Type: " ( InStr( dbuffer, "<?xml" ) + 3 >> 2 = 1 ? "text/xml"
					: "application/x-www-form-urlencoded" )
				If ( 7 != pos := 7 + InStr( Codepage_Charsets, "|" Do_NonBinary_Up "=" ) )
					hbuffer .= "; charset=" SubStr( Codepage_Charsets, pos, InStr( Codepage_Charsets, "|", 0, pos ) - pos )
				hbuffer .= "`r`n"
			}
			If ( IsUnicode )
				pos := &In_POST__Out_Data, rbuffsz := Content_Length >> 1
			Else
			{
			; If this isn't a UTF-16 environment, convert the POST data to UTF-16. rbuffsz = bytes
				If ( 0 < rbuffsz := DllCall( "MultiByteToWideChar", DW, MyACP, DW, 0, Ptr, &In_POST__Out_Data, DW, Content_Length, Ptr, 0, DW, 0 ) )
				{
					VarSetCapacity( rbuffer, rbuffsz + 1 << 1, 0 )
				; MultiByteToWideChar > http://msdn.microsoft.com/en-us/library/dd319072%28v=vs.85%29.aspx
					DllCall( "MultiByteToWideChar", DW, MyACP, DW, 0, Ptr, &In_POST__Out_Data, DW, Content_Length, Ptr, pos := &rbuffer, DW, rbuffsz )
				}
				Else MyErrors .= swp "converting codepage " MyACP " to " Convert_POST_To_Codepage ". 'MultiByteToWideChar' failed: Return value = " rbuffsz sel ErrorLevel sle A_LastError "`n"
			}
		; Convert the UTF-16 string to a multi-byte string in the chosen codepage
			If ( 0 < rbuffsz ) ; a zero or negative length here indicates a prior error
				If ( 0 < dbuffsz := DllCall( "WideCharToMultiByte", DW, Do_NonBinary_Up, DW, 0, Ptr, pos, DW, rbuffsz, Ptr, 0, DW, 0, Ptr, 0, Ptr, 0 ) )
				{
					VarSetCapacity( dbuffer, dbuffsz + 1, 0 )
				; WideCharToMultiByte > http://msdn.microsoft.com/en-us/library/dd374130%28v=vs.85%29.aspx
					DllCall( "WideCharToMultiByte", DW, Do_NonBinary_Up, DW, 0, Ptr, pos, DW, rbuffsz, Ptr, &dbuffer, DW, dbuffsz, Ptr, 0, Ptr, 0 )
					Content_Length := SubStr( dbuffsz + 0.0, 1, 1 + FLOOR( LOG( dbuffsz )))
					hbuffer .= "Content-Length: " Content_Length "`r`n"
				}
				Else MyErrors .= swp "converting codepage " MyACP " to " Convert_POST_To_Codepage ". 'WideCharToMultiByte' failed: Return value = " dbuffsz sel ErrorLevel sle A_LastError "`n"
			VarSetCapacity( rbuffer, 0 ) ; free this temporary buffer

		}

		If ( Do_Up_MD5_Hash ) ; The user wants HTTPRequest to auto-calculate the Content-MD5 header.
		{
; Update (2-28-2012, v2.45) - use Advapi32.dll to calculate the MD5 hash.
			VarSetCapacity( rbuffer, 20, 0 )
			rbuffer := 0

			If !( Do_File_Upload ) && !DllCall( "Advapi32\CryptHashData", Ptr, hHash, Ptr, &dbuffer, DW, Content_Length, DW, 0 )
				MyErrors .= swp "adding data to the hash object. 'CryptHashData' failed" sel ErrorLevel sle A_LastError "`n"

			If ( Do_File_Upload )
			{
				Loop
					If !DllCall( "ReadFile", Ptr, Do_File_Upload, Ptr, &dbuffer, DW, Content_Length - rbuffer < 4096 ? Content_Length - rbuffer : 4096, DW "*", dtsz, Ptr, 0 )
					{
						MyErrors .= swp "reading from the file """ Upload_File_Path """. 'ReadFile' failed" sel ErrorLevel sle A_LastError "`n"
						Break
					}
					Else If !DllCall( "Advapi32\CryptHashData", Ptr, hHash, Ptr, &dbuffer, DW, dtsz, DW, 0 )
					{
						MyErrors .= swp "adding data to the hash object. 'CryptHashData' failed" sel ErrorLevel sle A_LastError "`n"
						Break
					}
					Else If ( Content_Length <= rbuffer += dtsz )
						Break

				If !DllCall( "SetFilePointerEx", Ptr, Do_File_Upload, "Int64", 0, Ptr, 0, DW, 0 )
					MyErrors .= swp "resetting the pointer on the upload file. 'SetFilePointerEx' failed" sel ErrorLevel sle A_LastError "`n"
			}

; Get the hash bytes and convert it to base 64, then set it as the Content-MD5 header's value
			If !DllCall( "Advapi32\CryptGetHashParam", Ptr, hHash, DW, 2, Ptr, &rbuffer, DW "*", pos := 16, DW, 0 )
				MyErrors .= swp "getting the hash value. 'CryptGetHashParam' failed" sel ErrorLevel sle A_LastError "`n"

			hbuffer .= "Content-MD5: "
			Loop, 18
			{
				pos := *( &rbuffer + A_Index - 1 ) | (( 0xFFFF & pos ) << 8 )
				Loop % !Mod( A_Index, 3 ) * 4
					dtsz := 63 & ( pos >> 24 - 6 * A_Index ), hbuffer .= Chr( dtsz < 26 ? dtsz
					+ 65 : dtsz < 52 ? dtsz + 71 : dtsz < 62 ? dtsz - 4 : dtsz = 62 ? 43 : 47 )
			}

			StringTrimRight, hbuffer, hbuffer, 2
			hbuffer .= "==`r`n"
		}
	; Set up an INTERNET_BUFFERS structure in preparation for calling HttpSendRequestEx
	; Update 2.44 - the 'dswsructSize' member of the INTERNET_BUFFERS struct is padded on x64 systems to
	; align the next parameter (a pointer) to 64-bits.
		pos := 24 + PtrSize * 4 ; 40 bytes on x86 systems, 56 bytes on x64
		VarSetCapacity( INTERNET_BUFFERS, pos, 0 )
		NumPut( pos, INTERNET_BUFFERS, 0, DW )
		NumPut( Content_Length, INTERNET_BUFFERS, pos - 12, DW )
	}

; If needed, clean up the resources for the upload hash. 
	If ( Do_Up_MD5_Hash ) && !DllCall( "Advapi32\CryptDestroyHash", Ptr, hHash )
		MyErrors .= swp "releasing the hash object. 'CryptDestroyHash' failed" sel ErrorLevel sle A_LastError "`n"
	If ( Do_Up_MD5_Hash ) && !DllCall( "Advapi32\CryptReleaseContext", Ptr, hProv, DW, 0 )
		MyErrors .= swp "releasing the key container. 'CryptReleaseContext' failed" sel ErrorLevel sle A_LastError "`n"
	If ( Do_Up_MD5_Hash )
		DllCall( "FreeLibrary", Ptr, Do_Up_MD5_Hash )

; Update (future): assemble multipart/form-data here by combining the text from 'options' with
; the data the user wants to upload. How it works: the text portion of the multipart data is split
; at the first instance of "<MY DATA GOES HERE>", and the data buffer is expanded to account for the
; length of the data plus the (codepage converted) lengths of the two portions. The, the first
; portion is copied or converted and placed into the front of the data buffer. The data is copied
; to the right of that, and finally, the second portion is copied or converted to the right of that.
/*
	If ( Do_Multipart )
	{
	; The multipart envelope is baked here. The text is split at "<MY DATA GOES HERE>" and the two
	; parts are converted to the desired codepage. When the upload begins, the first chunk(s) begin
	; with the first part of the envelope, and the last chunk(s) end with the second. Doing it
	; piecemeal like this is the simplest way to support disk and memory sources for the data.
	; NOTE: when doing file-uploads WITH multipart/form-data, do NOT cache the file's data, instead
	; modify the first and last chunk to begin and end with the respective parts of the envelope.
	; Store the length of the first part of the envelope in "Do_Multipart"
	; Don't forget to change the Content-Length to the real size of the eventual data.

		StringGetPos, Do_Multipart, Multipart_Envelope, <MY DATA GOES HERE>
	}
*/

; Step  6: Build the pointer array for the accept types string
; The trick to this step is actually leaving all of the accept types in one string, then building
; the pointer array using the address + position of each member, then inserting nulls to make it
; look like a collection of independent null-terminated strings.
; First thing is to replace delimiting commas with newlines (but not quoted literal commas).
	Loop, Parse, Accept_Types, "
		If ( A_Index = 1 )
			StringReplace, Accept_Types, A_LoopField, `,, `n, A
		Else If ( A_Index & 1 )
		{
			StringReplace, Accept_PtrArray, A_LoopField, `,, `n, A
			Accept_Types .= Accept_PtrArray
		}
		Else Accept_Types .= """" A_LoopField """"

; Then trim whitespace around the delimiters and count how many accept-types there are
	Loop, Parse, Accept_Types, `n, %sws%
		If ( 1 = pos := A_Index )
			Accept_Types := A_LoopField
		Else Accept_Types .= "`n" A_LoopField

; Wipe the variable we'll use as the pointer array. The array itself should be null-terminated, so add an extra member.
	VarSetCapacity( Accept_PtrArray, pos * PtrSize + PtrSize, 0 )
	pos := 0
; For each member, put the address + offset into the pointer array, then end it with a null.
	Loop, Parse, Accept_Types, `n
	{
		NumPut( &Accept_Types + pos, Accept_PtrArray, A_Index * PtrSize - PtrSize, Ptr )
		pos += 1 + StrLen( A_LoopField ) << IsUnicode
		NumPut( 0, Accept_Types, pos - 1 - IsUnicode, IsUnicode ? "UShort" : "UChar" )
	}

; Set the default HTTP verb to 'POST' if there is data to upload, 'GET' otherwise.
	Method_Verb := Method_Verb != "" ? Method_Verb : 0 < Content_Length ? "POST" : "GET"
; Trim the leading CRLF from the headers buffer.
	StringTrimLeft, hbuffer, hbuffer, 2

; Do an error check before we load WinINet. If we have errors, don't continue.
; Afterwards, if we encounter errors, don't simply return but continue to the cleanup step.
	If ( MyErrors != "" )
	{
		If ( Do_File_Upload ) && !DllCall( "CloseHandle", Ptr, Do_File_Upload )
			MyErrors .= swp "closing the file """ Upload_File_Path """. 'CloseHandle' failed" sel ErrorLevel sle A_LastError "`n"
		StringTrimRight, In_Out_HEADERS, MyErrors, 1
		Return 0, ErrorLevel := Response_Code
	}
	
; Step 7: Load WinINet.dll and initialize the internet connection and request.
; Kernel32.dll\LoadLibrary > http://msdn.microsoft.com/en-us/library/ms684175%28v=VS.85%29.aspx
	If !( hWinINet := DllCall( "LoadLibrary" W_A, "Str", "WinINet.dll", Ptr ) )
		MyErrors .= swp "loading WinINet.dll. 'LoadLibrary" W_A "' failed: Return value = " hWinINet sel ErrorLevel sle A_LastError "`n"

; Initialize WinINet. InternetOpen > http://msdn.microsoft.com/en-us/library/aa385096%28v=VS.85%29.aspx
	Else	If !( hInternet := Internet_Open_Type != 3 ? DllCall( "WinINet\InternetOpen" W_A, Ptr, &Agent, DW, Internet_Open_Type, Ptr, 0, Ptr, 0, DW, 0, Ptr )
	: DllCall( "WinINet\InternetOpen" W_A, Ptr, &Agent, DW, 3, ptr, &proxy_url, Ptr, proxy_bypass = "" ? 0 : &proxy_bypass, DW, 0, Ptr ) )
		MyErrors .= swp "initializing WinINet. 'WinINet\InternetOpen" W_A "' failed: Return value = " hInternet sel ErrorLevel sle A_LastError "`n"

; Open a HTTP session. InternetConnect > http://msdn.microsoft.com/en-us/library/aa384363%28v=VS.85%29.aspx
; dwService -> INTERNET_SERVICE_HTTP = 3
	Else If !( hConnection := DllCall( "WinINet\InternetConnect" W_A, Ptr, hInternet, Ptr, &Host, DW, Port, Ptr, &User, Ptr, &Pass, DW, 3, DW, Internet_Flags, DW, 0, Ptr ) )
		MyErrors .= swp "opening a HTTP session. 'WinINet\InternetConnect" W_A "' failed: Return value = " hConnection sel ErrorLevel sle A_LastError "`n"

; Create a HTTP request. HttpOpenRequest > http://msdn.microsoft.com/en-us/library/aa384233%28v=VS.85%29.aspx
	Else If !( hRequest := DllCall( "WinINet\HttpOpenRequest" W_A, Ptr, hConnection, Ptr, &Method_Verb, Ptr, &URL, "Str", "HTTP/1.1", Ptr, 0, Ptr, &Accept_PtrArray, DW, Internet_Flags, Ptr, 0, Ptr ) )
		MyErrors .= swp "creating a HTTP request. 'WinINet\HttpOpenRequest" W_A "' failed: Return value = " hRequest sel ErrorLevel sle A_LastError "`n"

; Add headers. HttpAddRequestHeaders > http://msdn.microsoft.com/en-us/library/aa384227%28v=VS.85%29.aspx
; dwModifiers = (HTTP_ADDREQ_FLAG_ADD = 0x20000000) + (HTTP_ADDREQ_FLAG_REPLACE = 0x80000000)
	Else If ( hbuffer != "" ) && !DllCall( "WinINet\HttpAddRequestHeaders" W_A, Ptr, hRequest, Ptr, &hbuffer, DW, StrLen( hbuffer ), DW, 0xA0000000 )
		MyErrors .= swp "adding one or more headers to the request. 'WinINet\HttpAddRequestHeaders" W_A "' failed" sel ErrorLevel sle A_LastError "`nHeaders:`n" hbuffer

; Update (12-28-2011): Added security flags support. Security flags may be added/removed like normal flags
; InternetQueryOption > http://msdn.microsoft.com/en-us/library/aa385101%28v=VS.85%29.aspx
	Else If ( Security_Flags_Add || Security_Flags_Nix ) && !DllCall( "WinINet\InternetQueryOption" W_A, Ptr, hRequest, DW, 31, DW "*", Security_Flags, DW "*", 4 )
		MyErrors .= swp "retrieving the security flags. 'WinINet\InternetQueryOption" W_A "' failed" sel ErrorLevel sle A_LastError "`n"

; InternetSetOption > http://msdn.microsoft.com/en-us/library/aa385114%28v=VS.85%29.aspx
	Else If ( Security_Flags_Add || Security_Flags_Nix ) && !DllCall( "WinINet\InternetSetOption" W_A, Ptr, hRequest, DW, 31, DW "*", pos := ( ~Security_Flags_Nix & Security_Flags ) | Security_Flags_Add, DW "*", 4 )
		MyErrors .= swp "setting the security flags. 'WinINet\InternetSetOption" W_A "' failed: Flags value = " pos sel ErrorLevel sle A_LastError "`n"

; Step 8a: If there is no data to upload, submit the request via HttpSendRequest.
; HttpSendRequest > http://msdn.microsoft.com/en-us/library/aa384247%28v=VS.85%29.aspx
	Else If !( 0 < Content_Length ) && !DllCall( "WinINet\HttpSendRequest" W_A, Ptr, hRequest, Ptr, 0, DW, 0, Ptr, 0, DW, 0 )
		MyErrors .= swp "sending the " Method_Verb " request. 'WinINet\HttpSendRequest" W_A "' failed" sel ErrorLevel sle A_LastError "`n"

; Step 8b: If there is data to upload, begin submitting the request via HttpSendRequestEx, upload the data
; using InternetWriteFile, then end the request with HttpEndRequest.
; HttpSendRequestEx > http://msdn.microsoft.com/en-us/library/aa384318%28v=VS.85%29.aspx
	Else If ( 0 < Content_Length ) && !DllCall( "WinINet\HttpSendRequestEx" W_A, Ptr, hRequest, Ptr, &INTERNET_BUFFERS, Ptr, 0, DW, 0, Ptr, 0 )
		MyErrors .= swp "sending the " Method_Verb " request. 'WinINet\HttpSendRequestEx" W_A "' failed" sel ErrorLevel sle A_LastError "`n"
	Else If ( 0 < Content_Length )
	{
	; Here, we have a connection open to a remote resource and we should write data to it.
	; But first, notfy the callback function that we are about to upload data by passing '-1' to it.
		If ( Do_Callback ) && ( "CANCEL" = %Do_Callback_Func%( -1, Content_Length, Do_Callback_3rdParam ) )
			MyErrors .= cfc "Zero bytes were uploaded.`n"
		Else
		{
		; Loop until the size of the data uploaded is equal or greater than the Content-Length.
		; Actually, 'equal to' is the end condition, the 'greater than' is just good programming.
			size := 0 ; 'size' tracks the number of bytes actually uploaded so far.
			Loop
			{
				If ( Content_Length <= size ) || ( MyErrors != "" )
					Break
			; Define the first data chunk of up to 4096 bytes (put the address into 'pos')
			; NOTE: except with multipart data, 'dbuffsz' and 'Content-Length' are equal.
				If ( size < Do_Multipart )
				{
					; Upload the first part of the multipart envelope.
					pos := &rbuffer
					dtsz := Do_Multipart - size < 4096 ? Do_Multipart - size : 4096
				}
				Else If ( Do_Multipart + dbuffsz <= size )
				{
					; Upload the second part of the multipart envelope.
					pos := &rbuffer + Do_Multipart
					dtsz := Content_Length - size < 4096 ? Content_Length - size : 4096
				}
				; ReadFile > http://msdn.microsoft.com/en-us/library/aa365467%28v=VS.85%29.aspx
				Else If !( Do_File_Upload )
				{
					; Upload from memory
					pos := &dbuffer + size
					dtsz := dbuffsz - size < 4096 ? dbuffsz - size : 4096
				}
				Else If !DllCall( "ReadFile", Ptr, Do_File_Upload, Ptr, pos := &dbuffer, DW, dbuffsz - size < 4096 ? dbuffsz - size : 4096, DW "*", dtsz, Ptr, 0 )
				{
					; Upload from a file AND we couldn't read from the file
					MyErrors .= swp "reading from the file """ Upload_File_Path """. 'ReadFile' failed" sel ErrorLevel sle A_LastError "`n"
					Break
				}

			; Upload the chunk, and then increment 'size' by how many bytes were uploaded.
			; InternetWriteFile > http://msdn.microsoft.com/en-us/library/aa385128%28v=VS.85%29.aspx
				If !DllCall( "WinINet\InternetWriteFile", Ptr, hRequest, Ptr, pos, DW, dtsz + 0, DW "*", dtsz )
					MyErrors .= swp "uploading the POST data. 'WinINet\InternetWriteFile' failed" sel ErrorLevel sle A_LastError "`n"
				Else
				{
					size += dtsz

				; If we have a callback function, tell it what percent has been uploaded
					If ( Do_Callback ) && ( "CANCEL" = %Do_Callback_Func%( size / Content_Length - 1, Content_Length, Do_Callback_3rdParam ) )
						MyErrors .= cfc size " bytes were uploaded.`n"
				}
			}
		; Close the file handle (if the data was uploaded from a file).
		; CloseHandle > http://msdn.microsoft.com/en-us/library/ms724211%28v=vs.85%29.aspx
			If ( Do_File_Upload ) && !DllCall( "CloseHandle", Ptr, Do_File_Upload )
				MyErrors .= swp "closing the file """ Upload_File_Path """. 'CloseHandle' failed" sel ErrorLevel sle A_LastError "`n"
		}
		; We're done uploading data, so end the request.
		; HttpEndRequest > http://msdn.microsoft.com/en-us/library/aa384230%28v=VS.85%29.aspx
		DllCall( "WinINet\HttpEndRequest" W_A, Ptr, hRequest, Ptr, 0, DW, 0, Ptr, 0 )
	}

; Step 9: Wait until data is available, then get the response headers.
	Content_Length := size := rbuffsz := 0
	If ( MyErrors = "" )
	{
		If ( Method_Verb != "HEAD" )
			; InternetQueryDataAvailable > http://msdn.microsoft.com/en-us/library/aa385100%28v=VS.85%29.aspx
			DllCall( "WinINet\InternetQueryDataAvailable", Ptr, hRequest, DW "*", Content_Length, DW, 0, Ptr, 0 )

		; Get the response headers separated by CRLF. The first line has the HTTP response code
		; HttpQueryInfo > http://msdn.microsoft.com/en-us/library/aa384238%28v=VS.85%29.aspx
		; HTTP_QUERY_RAW_HEADERS_CRLF = 22. First-try buffer size = 4K
		If VarSetCapacity( hbuffer, hbuffsz := 4096, 0 )
		&& !DllCall( "WinINet\HttpQueryInfo" W_A, Ptr, hRequest, DW, 22, Ptr, &hbuffer, DW "*", hbuffsz, Ptr, 0 )
		&& VarSetCapacity( hbuffer, hbuffsz, 0 )
		&& !DllCall( "WinINet\HttpQueryInfo" W_A, Ptr, hRequest, DW, 22, Ptr, &hbuffer, DW "*", hbuffsz, Ptr, 0 )
			MyErrors .= swp "reading the response headers. 'WinINet\HttpQueryInfo" W_A "' failed" sel ErrorLevel sle A_LastError "`n"
		Else
		{
			; We've got the response headers, but don't copy them to the output var yet.
			; Replace CRLF with LF, get the response code, and see if there's a Content-Length.
			VarSetCapacity( hbuffer, -1 )
			StringReplace, hbuffer, hbuffer, `r`n, `n, A
			StringMid, Response_Code, hbuffer, InStr( hbuffer, " " ) + 1, 3
			If ( Method_Verb != "HEAD" ) && ( 17 != pos := 17 + InStr( hbuffer, "`nContent-Length: " ) )
				StringMid, Content_Length, hbuffer, pos, InStr( hbuffer, "`n", 0, pos ) - pos
			Do_Dn_MD5_Hash := InStr( hbuffer, "`nContent-MD5:" )
		}
	}
	Else hbuffer := ""

; Step 10: Download the response data
	If ( Content_Length ) && ( MyErrors = "" )
	{
	; If we're downloading to a file, try to open the target file with GENERIC_WRITE (0x40000000) permission.
		If ( Do_Download_To_File ) && !( Do_Download_To_File := DllCall( "CreateFile" W_A, Ptr, &output_file_path, DW, 0xC0000000, DW, 0, Ptr, 0, DW, 4, DW, 0, Ptr, 0, Ptr ) )
			MyErrors .= swp "opening/creating the output file for writing data: """ output_file_path """. 'CreateFile" W_A "' failed" sel ErrorLevel sle A_LastError "`n"
	; Then, if we're resuming a download, move the write-pointer to the end of the file.
	; SetFilePointerEx > http://msdn.microsoft.com/en-us/library/aa365542%28v=VS.85%29.aspx
		Else If ( Do_Download_Resume ) && !DllCall( "SetFilePointerEx", Ptr, Do_Download_To_File, "Int64", Do_Download_Resume, Ptr, 0, DW, 0 )
			MyErrors .= swp "seeking to the end of the output file for resuming the download. 'SetFilePointerEx' failed" sel ErrorLevel sle A_LastError "`n"
	; If we have a callback function, inform it that we're about to begin downloading data.
		Else If ( Do_Callback ) && ( "CANCEL" = %Do_Callback_Func%( Do_Download_Resume, Content_Length + Do_Download_Resume, Do_Callback_3rdParam ) )
			MyErrors .= cfc "Zero bytes were downloaded.`n"
		Else
		{
; Update (2.46 2-29-2012) - The computed MD5 hash will be added if the response headers have a Content-MD5
			If ( Do_Dn_MD5_Hash )
				If !( Do_Dn_MD5_Hash := DllCall("LoadLibrary" W_A, "Str", "Advapi32.dll" ) )
					MyErrors .= swp "loading Advapi32.dll to calculate the Content-MD5 header. 'LoadLibrary" W_A "' failed" sel ErrorLevel sle A_LastError "`n"
				Else If !DllCall( "Advapi32\CryptAcquireContext" W_A, Ptr "*", hProv := 0, Ptr, 0, Ptr, 0, DW, 1, DW, 0xF0000000 )
					MyErrors .= swp "acquiring the key container to calculate the Content-MD5 header. 'CryptAcquireContext' failed" sel ErrorLevel sle A_LastError "`n"
				Else If !DllCall( "Advapi32\CryptCreateHash", Ptr, hProv, DW, 0x8003, Ptr, 0, DW, 0, Ptr "*", hHash := 0 )
					MyErrors .= swp "creating the hash object to calculate the Content-MD5 header. 'CryptCreateHash' failed" sel ErrorLevel sle A_LastError "`n"

		; Download the response data. Initialize the d-buffer to hold the reported content length plus 4K
			VarSetCapacity( dbuffer, dbuffsz := Do_Download_To_File ? 4096 : 4096 + Content_Length, 0 )
			Loop
			{
; Update (1-8-2012): the data downloading loop no longer uses dynamic variables. Instead, if the d-buffer is
; too small, make space in the r-buffer to hold 4K plus the data in the d-buffer and download to the end of the
; r-buffer. If data was downloaded, copy the data from the d-buffer to the r-buffer, expand the d-buffer, and
; copy all of the data (old + new) back to the d-buffer. If ever InternetReadFile fails, or downloads zero
; bytes, that means we're done.
				If ( MyErrors != "" )
					Break
				Else If ( Do_Download_To_File )
					pos := &dbuffer
				Else If ( size + 4096 < Content_Length )
					pos := &dbuffer + size
				Else
				{
					VarSetCapacity( rbuffer, rbuffsz := size + 4096 + 1, 0 )
					pos := &rbuffer + size
				}

			; Now that the target buffer has been determined, download the next chunk.
			; InternetReadFile > http://msdn.microsoft.com/en-us/library/aa385103%28v=VS.85%29.aspx
				If !DllCall( "WinINet\InternetReadFile", Ptr, hRequest, Ptr, pos, DW, 4096, DW "*", dtsz )
					MyErrors .= swp "downoading data. 'WinINet\InternetReadFile' failed" sel ErrorLevel sle A_LastError "`n"
				Else If !dtsz
				{
					If ( Do_Callback )
						%Do_Callback_Func%( 1, Content_Length + Do_Download_Resume, Do_Callback_3rdParam )
					Break
				}
			; WriteFile > http://msdn.microsoft.com/en-us/library/aa365747%28v=vs.85%29.aspx
				Else If ( Do_Download_To_File ) && !DllCall( "WriteFile", Ptr, Do_Download_To_File, Ptr, pos, DW, dtsz, DW "*", 0, Ptr, 0 )
					MyErrors .= swp "writing data to the disk. 'WriteFile' failed" sel ErrorLevel sle A_LastError "`n"
				Else If !( Do_Download_To_File ) && ( size < rbuffsz )
				{
					DllCall( "RtlMoveMemory", Ptr, &rbuffer, Ptr, &dbuffer, DW, size )
					VarSetCapacity( dbuffer, Content_Length := 4096 + ( size += dtsz ), 0 )
					DllCall( "RtlMoveMemory", Ptr, &dbuffer, Ptr, &rbuffer, DW, size )
					rbuffsz := 0
				}
				Else size += dtsz

			; Add data to the hash object if we're checking the MD5 hash
				If ( Do_Dn_MD5_Hash ) && !DllCall( "Advapi32\CryptHashData", Ptr, hHash, Ptr, pos, DW, dtsz, DW, 0 )
					MyErrors .= swp "adding data to the hash object. 'CryptHashData' failed" sel ErrorLevel sle A_LastError "`n"


				If ( Do_Callback ) && ( "CANCEL" = %Do_Callback_Func%( ( size + Do_Download_Resume ) / ( Content_Length + Do_Download_Resume ), Content_Length + Do_Download_Resume, Do_Callback_3rdParam ) )
					MyErrors .= cfc size " bytes were downloaded.`n"
			}
			If ( Do_Download_To_File ) && !DllCall( "CloseHandle", Ptr, Do_Download_To_File )
				MyErrors .= swp "closing the file """ output_file_path """. 'CloseHandle' failed" sel ErrorLevel sle A_LastError "`n"
		}
	}

; Step 11: Close handles, free the dll, and add the MD5 hash check if called for.
; InternetCloseHandle > http://msdn.microsoft.com/en-us/library/aa384350%28v=VS.85%29.aspx
	DllCall( "WinINet\InternetCloseHandle", Ptr, hRequest )
	DllCall( "WinINet\InternetCloseHandle", Ptr, hConnection )
	DllCall( "WinINet\InternetCloseHandle", Ptr, hInternet )
	DllCall( "FreeLibrary", Ptr, hWinINet )

	If ( Do_Dn_MD5_Hash )
	{
; Get the hash bytes and convert it to base 64, then set it as the Content-MD5 header's value
		VarSetCapacity( rbuffer, 20, 0 )
		If !DllCall( "Advapi32\CryptGetHashParam", Ptr, hHash, DW, 2, Ptr, &rbuffer, DW "*", pos := 16, DW, 0 )
			MyErrors .= swp "getting the hash value. 'CryptGetHashParam' failed" sel ErrorLevel sle A_LastError "`n"
		If !DllCall( "Advapi32\CryptDestroyHash", Ptr, hHash )
			MyErrors .= swp "releasing the hash object. 'CryptDestroyHash' failed" sel ErrorLevel sle A_LastError "`n"
		If !DllCall( "Advapi32\CryptReleaseContext", Ptr, hProv, DW, 0 )
			MyErrors .= swp "releasing the key container. 'CryptReleaseContext' failed" sel ErrorLevel sle A_LastError "`n"
		DllCall( "FreeLibrary", Ptr, Do_Dn_MD5_Hash )

		options := "`nComputed-MD5: "
		Loop, 18
		{
			pos := *( &rbuffer + A_Index - 1 ) | (( 0xFFFF & pos ) << 8 )
			Loop % !Mod( A_Index, 3 ) * 4
				dtsz := 63 & ( pos >> 24 - 6 * A_Index ), options .= Chr( dtsz < 26 ? dtsz
				+ 65 : dtsz < 52 ? dtsz + 71 : dtsz < 62 ? dtsz - 4 : dtsz = 62 ? 43 : 47 )
		}
		StringReplace, hbuffer, hbuffer, % "`nContent-MD5:", % SubStr( options, 1, -2 ) "==`nContent-MD5:"
	}

; Step 12: Copy the response data and headers into the output buffers, respecting the pertinent options.
	If ( size ) && !( Do_Download_To_File )
	{
	; First, detect the content type to see whether we CAN treat it like text.
		If ( 15 != pos := 15 + InStr( hbuffer, "`nContent-Type: " ) )
			Content_Type := SubStr( hbuffer, pos, InStr( hbuffer "`n", "`n", 0, pos ) - pos )
		Else Content_Type := Expected_Type

	; Extract the charset information, if it's present
		If ( 7 != pos := 7 + InStr( Content_Type .= "`n" Expected_Type, "charset=" ) )
		&& ( pos := InStr( Codepage_Charsets, SubStr( Content_Type, pos
			, InStr( Content_Type ";" , ";", 0, pos ) - pos ) "|" ) )
			StringMid, Convert_POST_To_Codepage, Codepage_Charsets, pos - 5, 5
		Else Convert_POST_To_Codepage := IsUnicode ? "65001" : MyACP

	; Then, determine whether we should convert the data to a different codepage or not.
		StringLeft, Content_Type, Content_Type, InStr( Content_Type ";", ";" ) - 1
		If !( pos := InStr( Content_Type, "text/" ) = 1 )
			Loop, Parse, Text_Content_Subtypes, /
				If ( pos |= 0 < InStr( Content_Type, "/" A_LoopField ) )
					Break

	; So, now we know whether or not to treat the data as text, or as binary
		If ( Do_Binary_Down ) || !( pos ) || ( Convert_POST_To_Codepage = MyACP )
		{
			VarSetCapacity( In_POST__Out_Data, size + 2, 0 )
			DllCall( "RtlMoveMemory", Ptr, &In_POST__Out_Data, Ptr, &dbuffer, DW, size )
			If ( pos )
				VarSetCapacity( In_POST__Out_Data, -1 )
		}
		Else
		{
		; convert the text data's codepage to whatever codepage the script is using.
			If ( Convert_POST_To_Codepage = "01200" )
			{
			; the downloaded data is in UTF-16 already (I don't know if this ever happens IRL).
				pos := &dbuffer
				rbuffsz := size >> 1
			}
			Else If ( 0 < rbuffsz := DllCall( "MultiByteToWideChar", DW, Convert_POST_To_Codepage, DW, 0, Ptr, &dbuffer, DW, size, Ptr, 0, DW, 0 ) )
			{
				VarSetCapacity( rbuffer, rbuffsz + 1 << 1 )
				DllCall( "MultiByteToWideChar", DW, Convert_POST_To_Codepage, DW, 0, Ptr, &dbuffer, DW, size, Ptr, pos := &rbuffer, DW, rbuffsz )
			}
			Else MyErrors .= swp "converting codepage " Convert_POST_To_Codepage " to " MyACP ". 'MultiByteToWideChar' failed: Return value = " rbuffsz sel ErrorLevel sle A_LastError "`n"

			If ( IsUnicode )
			{
				VarSetCapacity( In_POST__Out_Data, rbuffsz + 1 << 1, 0 )
				DllCall( "RtlMoveMemory", Ptr, &In_POST__Out_Data, Ptr, &rbuffer, DW, rbuffsz << 1 )
				VarSetCapacity( In_POST__Out_Data, -1 )
			}
			Else If ( 0 < rbuffsz ) && ( 0 < dbuffsz := DllCall( "WideCharToMultiByte", DW, MyACP, DW, 0, Ptr, pos, DW, rbuffsz, Ptr, 0, DW, 0, Ptr, 0, Ptr, 0 ) )
			{
				VarSetCapacity( In_POST__Out_Data, dbuffsz + 1, 0 )
				DllCall( "WideCharToMultiByte", DW, MyACP, DW, 0, Ptr, pos, DW, rbuffsz, Ptr, &In_POST__Out_Data, DW, dbuffsz, Ptr, 0, Ptr, 0 )
				size := dbuffsz
				VarSetCapacity( In_POST__Out_Data, -1 )
			}
			Else MyErrors .= swp "converting codepage " Convert_POST_To_Codepage " to " MyACP ". 'WideCharToMultiByte' failed: Return value = " dbuffsz sel ErrorLevel sle A_LastError "`n"
		}
	}
	; If there was no data downloaded, AND there were no errors so far, clear the data output var.
	Else If ( MyErrors = "" )
		In_POST__Out_Data := ""

	In_Out_HEADERS := SubStr( hbuffer, 1, -1 ) . SubStr( MyErrors, 1, -1 )
	Return size, dbuffer := "", hbuffer := "", rbuffer := "", ErrorLevel := Response_Code
} ; HTTPRequest( URL, byref In_POST__Out_Data="", byref In_Out_HEADERS="", Options="" ) -----------------------

/*! TheGood
    AHKsock - A simple AHK implementation of Winsock.
    http://www.autohotkey.com/forum/viewtopic.php?p=355775
    Last updated: January 19, 2011
    
FUNCTION LIST:

________________________________________
AHKsock_Listen(sPort, sFunction = False)

Tells AHKsock to listen on the port in sPort, and call the function in sFunction when events occur. If sPort is a port on
which AHKsock is already listening, the action taken depends on sFunction:
    - If sFunction is False, AHKsock will stop listening on the port in sPort.
    - If sFunction is "()", AHKsock will return the name of the current function AHKsock calls when
      a client connects on the port in sPort.
    - If sFunction is a valid function, AHKsock will set that function as the new function to call
      when a client connects on the port in sPort.

Returns blank on success. On failure, it returns one of the following positive integer:
    2: sFunction is not a valid function.
    3: The WSAStartup() call failed. The error is in ErrorLevel.
    4: The Winsock DLL does not support version 2.2.
    5: The getaddrinfo() call failed. The error is in ErrorLevel.
    6: The socket() call failed. The error is in ErrorLevel.
    7: The bind() call failed. The error is in ErrorLevel.
    8: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
    9: The listen() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

See the section titled "STRUCTURE OF THE EVENT-HANDLING FUNCTION AND MORE INFO ABOUT SOCKETS" for more info about how the
function in sFunction interacts with AHKsock.

________________________________________
AHKsock_Connect(sName, sPort, sFunction)

Tells AHKsock to connect to the hostname or IP address in sName on the port in sPort, and call the function in sFunction
when events occur.

Although the function will return right away, the connection attempt will still be in progress. Once the connection attempt
is over, successful or not, sFunction will receive the CONNECTED event. Note that it is important that once AHKsock_Connect
returns, the current thread must stay (or soon after must become) interruptible so that sFunction can be called once the
connection attempt is over.

AHKsock_Connect can only be called again once the previous connection attempt is over. To check if AHKsock_Connect is ready
to make another connection attempt, you may keep polling it by calling AHKsock_Connect(0,0,0) until it returns False.

Returns blank on success. On failure, it returns one of the following positive integer:
    1: AHKsock_Connect is still processing a connection attempt. ErrorLevel contains the name and the port of that
       connection attempt, separated by a tab.
    2: sFunction is not a valid function.
    3: The WSAStartup() call failed. The error is in ErrorLevel.
    4: The Winsock DLL does not support version 2.2.
    5: The getaddrinfo() call failed. The error is in ErrorLevel.
    6: The socket() call failed. The error is in ErrorLevel.
    7: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
    8: The connect() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

See the section titled "STRUCTURE OF THE EVENT-HANDLING FUNCTION AND MORE INFO ABOUT SOCKETS" for more info about how the
function in sFunction interacts with AHKsock.

_______________________________________
AHKsock_Send(iSocket, ptrData, iLength)

Sends the data of length iLength to which ptrData points to the connected socket in iSocket.

Returns the number of bytes sent on success. This can be less than the number requested to be sent in the iLength parameter,
i.e. between 1 and iLength. This would occur if no buffer space is available within the transport system to hold the data to
be transmitted, in which case the number of bytes sent can be between 1 and the requested length, depending on buffer
availability on both the client and server computers. On failure, it returns one of the following negative integer:
    -1: WSAStartup hasn't been called yet.
    -2: Received WSAEWOULDBLOCK. This means that calling send() would have blocked the thread.
    -3: The send() call failed. The error is in ErrorLevel.
    -4: The socket specified in iSocket is not a valid socket. This means either that the socket in iSocket hasn't been
        created using AHKsock_Connect or AHKsock_Listen, or that the socket has already been destroyed.
    -5: The socket specified in iSocket is not cleared for sending. You haven't waited for the SEND event before calling,
        either ever, or not since you last received WSAEWOULDBLOCK.

You may start sending data to the connected socket in iSocket only after the socket's associated function receives the first
SEND event. Upon receiving the event, you may keep calling AHKsock_Send to send data until you receive the error -2, at
which point you must wait once again until you receive another SEND event before sending more data. Not waiting for the SEND
event results in receiving error -5 when calling AHKsock_Send.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

____________________________________________
AHKsock_ForceSend(iSocket, ptrData, iLength)

This function is exactly the same as AHKsock_Send, but with three differences:
    - If only part of the data could be sent, it will automatically keep trying to send the remaining part.
    - If it receives WSAEWOULDBLOCK, it will wait for the socket's SEND event and try sending the data again.
    - If the data buffer to send is larger than the socket's send buffer size, it will automatically send the data in
      smaller chunks in order to avoid a performance hit. See http://support.microsoft.com/kb/823764 for more info.

Therefore, AHKsock_ForceSend will return only when all the data has been sent. Because this function relies on waiting for
the socket's SEND event before continuing to send data, it cannot be called in a critical thread. Also, for the same reason,
it cannot be called from a socket's associated function (not specifically iSocket's associated function, but any socket's
associated function).

Another limitation to consider when choosing between AHKsock_Send and AHKsock_ForceSend is that AHKsock_ForceSend will not
return until all the data has been sent (unless an error occurs). Although the script will still be responsive (new threads
will still be able to launch), the thread from which it was called will not resume until it returns. Therefore, if sending
a large amount of data, you should either use AHKsock_Send, or use AHKsock_ForceSend by feeding it smaller pieces of the
data, allowing you to update the GUI if necessary (e.g. a progress bar).

Returns blank on success, which means that all the data to which ptrData points of length iLength has been sent. On failure,
it returns one of the following negative integer:
    -1: WSAStartup hasn't been called yet.
    -3: The send() call failed. The error is in ErrorLevel.
    -4: The socket specified in iSocket is not a valid socket. This means either that the socket in iSocket hasn't been
        created using AHKsock_Connect or AHKsock_Listen, or that the socket has already been destroyed.
    -5: The current thread is critical.
    -6: The getsockopt() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

____________________________________________
AHKsock_Close(iSocket = -1, iTimeout = 5000)

Closes the socket in iSocket. If no socket is specified, AHKsock_Close will close all the sockets on record, as well as
terminate use of the Winsock 2 DLL (by calling WSACleanup). If graceful shutdown cannot be attained after the timeout
specified in iTimeout (in milliseconds), it will perform a hard shutdown before calling WSACleanup to free resources. See
the section titled "NOTES ON CLOSING SOCKETS AND AHKsock_Close" for more information.

Returns blank on success. On failure, it returns one of the following positive integer:
    1: The shutdown() call failed. The error is in ErrorLevel. AHKsock_Close forcefully closed the socket and freed the
       associated resources.

Note that when AHKsock_Close is called with no socket specified, it will never return an error.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

___________________________________________________________
AHKsock_GetAddrInfo(sHostName, ByRef sIPList, bOne = False)

Retrieves the list of IP addresses that correspond to the hostname in sHostName. The list is contained in sIPList, delimited
by newline characters. If bOne is True, only one IP (the first one) will be returned.

Returns blank on success. On failure, it returns one of the following positive integer:
    1: The WSAStartup() call failed. The error is in ErrorLevel.
    2: The Winsock DLL does not support version 2.2.
    3: Received WSAHOST_NOT_FOUND. No such host is known.
    4: The getaddrinfo() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

_________________________________________________________________________
AHKsock_GetNameInfo(sIP, ByRef sHostName, sPort = 0, ByRef sService = "")

Retrieves the hostname that corresponds to the IP address in sIP. If a port in sPort is supplied, it also retrieves the
service that corresponds to the port in sPort.

Returns blank on success. On failure, it returns on of the following positive integer:
    1: The WSAStartup() call failed. The error is in ErrorLevel.
    2: The Winsock DLL does not support version 2.2.
    3: The IP address supplied in sIP is invalid.
    4: The getnameinfo() call failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

______________________________________________
AHKsock_SockOpt(iSocket, sOption, iValue = -1)

Retrieves or sets a socket option. Supported options are:
    SO_KEEPALIVE: Enable/Disable sending keep-alives. iValue must be True/False to enable/disable. Disabled by default.
    SO_SNDBUF:    Total buffer space reserved for sends. Set iValue to 0 to completely disable the buffer. Default is 8 KB.
    SO_RCVBUF:    Total buffer space reserved for receives. Default is 8 KB.
    TCP_NODELAY:  Enable/Disable the Nagle algorithm for send coalescing. Set iValue to True to disable the Nagle algorithm,
                  set iValue to False to enable the Nagle algorithm, which is the default.

It is usually best to leave these options to their default (especially the Nagle algorithm). Only change them if you
understand the consequences. See MSDN for more information on those options.

If iValue is specified, it sets the option to iValue and returns blank on success. If iValue is left as -1, it returns the
value of the option specified. On failure, it returns one of the following negative integer:
    -1: The getsockopt() failed. The error is in ErrorLevel.
    -2: The setsockopt() failed. The error is in ErrorLevel.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

_______________________________________
AHKsock_Settings(sSetting, sValue = "")

Changes the AHKsock setting in sSetting to sValue. If sValue is blank, the current value for that setting is returned. If
sValue is the word "Reset", the setting is restored to its default value. The possible settings are:
    Message: Determines the Windows message numbers used to monitor network events. The message number in iMessage and the
             next number will be used. Default value is 0x8000. For example, calling AHKsock_Settings("Message", 0x8005)
             will cause AHKsock to use 0x8005 and 0x8006 to monitor network events.
    Buffer:  Determines the size of the buffer (in bytes) used when receiving data. This is thus the maximum size of bData
             when the RECEIVED event is raised. If the data received is more than the buffer size, multiple recv() calls
             (and thus multiple RECEIVED events) will be needed. Note that you shouldn't use this setting as a means of
             delimiting frames. See the "NOTES ON RECEIVING AND SENDING DATA" section for more information about receiving
             and sending data. Default value is 64 KB, which is the maximum for TCP.

If you do call AHKsock_Settings to change the values from their default ones, it is best to do so at the beginning of the
script. The message number used cannot be changed as long as there are active connections.

______________________________________
AHKsock_ErrorHandler(sFunction = """")

Sets the function in sFunction to be the new error handler. If sFunction is left at its default value, it returns the name
of the current error handling function.

An error-handling function is optional, but may be useful when troubleshooting applications. The function will be called
anytime there is an error that arises in a thread which wasn't called by the user but by the receival of a Windows message
which was registered using OnMessage.

The function in sFunction must be of the following format:
MyErrorHandler(iError, iSocket)

The possible values for iError are:
     1: The connect() call failed. The error is in ErrorLevel.
     2: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
     3: The socket() call failed. The error is in ErrorLevel.
     4: The WSAAsyncSelect() call failed. The error is in ErrorLevel.
     5: The connect() call failed. The error is in ErrorLevel.
     6: FD_READ event received with an error. The error is in ErrorLevel. The socket is in iSocket.
     7: The recv() call failed. The error is in ErrorLevel. The socket is in iSocket.
     8: FD_WRITE event received with an error. The error is in ErrorLevel. The socket is in iSocket.
     9: FD_ACCEPT event received with an error. The error is in ErrorLevel. The socket is in iSocket.
    10: The accept() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
    11: The WSAAsyncSelect() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
    12: The listen() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
    13: The shutdown() call failed. The error is in ErrorLevel. The socket is in iSocket.

For the failures which affect ErrorLevel, ErrorLevel will contain either the reason the DllCall itself failed (ie. -1, -2,
An, etc... as laid out in the AHK docs for DllCall) or the Windows Sockets Error Code as defined at:
http://msdn.microsoft.com/en-us/library/ms740668

__________________________________________________________________
NOTES ON SOCKETS AND THE STRUCTURE OF THE EVENT-HANDLING FUNCTION:

The functions used in the sFunction parameter of AHKsock_Listen and AHKsock_Connect must be of the following format:

MyFunction(sEvent, iSocket = 0, sName = 0, sAddr = 0, sPort = 0, ByRef bData = 0, bDataLength = 0)

The variable sEvent contains the event for which MyFunction was called. The event raised is associated with one and only one
socket; the one in iSocket. The meaning of the possible events that can occur depend on the type of socket involved. AHKsock
deals with three different types of sockets:
    - Listening sockets: These sockets are created by a call to AHKsock_Listen. All they do is wait for clients to request
      a connection. These sockets will never appear as the iSocket parameter because requests for connections are
      immediately accepted, and MyFunction immediately receives the ACCEPTED event with iSocket set to the accepted socket.
    - Accepted sockets: These sockets are created once a listening socket receives an incoming connection attempt from a
      client and accepts it. They are thus the sockets that servers use to communicate with clients.
    - Connected sockets: These sockets are created by a successful call to AHKsock_Connect. These are the sockets that
      clients use to communicate with servers.

More info about sockets:
    - You may have multiple client sockets connecting to the same listening socket (ie. on the same port).
    - You may have multiple listening sockets for different ports.
    - You cannot have more than one listening socket for the same port (or you will receive a bind() error).
    - Every single connection between a client and a server will have its own client socket on the client side, and its own
      server (accepted) socket on the server side.

For all of the events that the event-handling function receives,
    - sEvent contains the event that occurred (as described below),
    - iSocket contains the socket on which the event occurred,
    - sName contains a value which depends on the type of socket in iSocket:
        - If the socket is an accepted socket, sName is empty.
        - If the socket is a connected socket, sName is the same value as the sName parameter that was used when
          AHKsock_Connect was called to create the socket. Since AHKsock_Connect accepts both hostnames and IP addresses,
          sName may contain either.
    - sAddr contains the IP address of the socket's endpoint (i.e. the peer's IP address). This means that if the socket in
      iSocket is an accepted socket, sAddr contains the IP address of the client. Conversely, if it is a connected socket,
      sAddr contains the server's IP.
    - sPort contains the server port on which the connection was accepted.

Obviously, if your script only calls AHKsock_Listen (acting as a server) or AHKsock_Connect (acting as a client) you don't
need to check if the socket in iSocket is an accepted socket or a connected socket, since it can only be one or the other.
But if you do call both AHKsock_Listen and AHKsock_Connect with both of them using the same function (e.g. MyFunction), then
you will need to check what type of socket iSocket is by checking the sName parameter.

Of course, it would be easier to simply have two different functions, for example, MyFunction1 and MyFunction2, with one
handling the server part and the other handling the client part so that you don't need to check what type of socket iSocket
is when each function is called. However, this might not be necessary if both server and client are "symmetrical" (i.e. the
conversation doesn't actually change whether or not we're on the server side or the client side). See Example 3 for an
example of this, where only one function is used for both server and client sockets.

The variable sEvent can be one of the following values if iSocket is an accepted socket:
    sEvent =      Event Description:
    ACCEPTED      A client connection was accepted (see the "Listening sockets" section above for more details).
    CONNECTED     <Does not occur on accepted sockets>
    DISCONNECTED  The client disconnected (see AHKsock_Close for more details).
    SEND          You may now send data to the client (see AHKsock_Send for more details).
    RECEIVED      You received data from the client. The data received is in bData and the length is in bDataLength.
    SENDLAST      The client is disconnecting. This is your last chance to send data to it. Once this function returns,
                  disconnection will occur. This event only occurs on the side which did not initiate shutdown (see
                  AHKsock_Close for more details).

The variable sEvent can be one of the following values if iSocket is a connected socket:
    sEvent =      Event Description:
    ACCEPTED      <Does not occur on connected sockets>
    CONNECTED     The connection attempt initiated by calling AHKsock_Connect has completed (see AHKsock_Connect for more
                  details). If it was successful, iSocket will equal the client socket. If it failed, iSocket will equal -1.
                  To get the error code that the failure returned, set an error handling function with AHKsock_ErrorHandler,
                  and read ErrorLevel when iError is equal to 1.
    DISCONNECTED  The server disconnected (see AHKsock_Close for more details).
    SEND          You may now send data to the server (see AHKsock_Send for more details).
    RECEIVED      You received data from the server. The data received is in bData and the length is in bDataLength.
    SENDLAST      The server is disconnecting. This is your last chance to send data to it. Once this function returns,
                  disconnection will occur. This event only occurs on the side which did not initiate shutdown (see 
                  AHKsock_Close for more details).

More information: The event-handling functions described in here are always called with the Critical setting on. This is
necessary in order to ensure proper processing of messages. Note that as long as the event-handling function does not
return, AHKsock cannot process other network messages. Although messages are buffered, smooth operation might suffer when
letting the function run for longer than it should.

___________________________________________
NOTES ON CLOSING SOCKETS AND AHKsock_Close:

There are a few things to note about the AHKsock_Close function. The most important one is this: because the OnExit
subroutine cannot be made interruptible if running due to a call to Exit/ExitApp, AHKsock_Close will not be able to execute
a graceful shutdown if it is called from there. 

A graceful shutdown refers to the proper way of closing a TCP connection. It consists of an exchange of special TCP messages
between the two endpoints to acknowledge that the connection is about to close. It also fires the SENDLAST event in the
socket's associated function to notify that this is the last chance it will have to send data before disconnection. Note
that listening sockets cannot (and therefore do not need to) be gracefully shutdown as it is not an end-to-end connection.
(In practice, you will never have to manually call AHKsock_Close on a listening socket because you do not have access to
them. The socket is closed when you stop listening by calling AHKsock_Listen with no specified value for the second
parameter.)

In order to allow the socket(s) connection(s) to gracefully shutdown (which is always preferable), AHKsock_Close must be
called in a thread which is, or can be made, interruptible. If it is called with a specified socket in iSocket, it will
initiate a graceful shutdown for that socket alone. If it is called with no socket specified, it will initiate a graceful
shutdown for all connected/accepted sockets, and once done, deregister itself from the Windows Sockets implementation and
allow the implementation to free any resources allocated for Winsock (by calling WSACleanup). In that case, if any
subsequent AHKsock function is called, Winsock will automatically be restarted.

Therefore, before exiting your application, AHKsock_Close must be called at least once with no socket specified in order to
free Winsock resources. This can be done in the OnExit subroutine, either if you do not wish to perform a graceful shutdown
(which is not recommended), or if you have already gracefully shutdown all the sockets individually before calling
Exit/ExitApp. Of course, it doesn't have to be done in the OnExit subroutine and can be done anytime before (which is the
recommended method because AHKsock will automatically gracefully shutdown all the sockets on record).

This behaviour has a few repercussions on your application's design. If the only way for the user to terminate your
application is through AHK's default Exit menu item in the tray menu, then upon selecting the Exit menu item, the OnExit sub
will fire, and your application will not have a chance to gracefully shutdown connected sockets. One way around this is to
add your own menu item which will in turn call AHKsock_Close with no socket specified before calling ExitApp to enter the
OnExit sub. See AHKsock Example 1 for an example of this.

This is how the graceful shutdown process occurs between two connected peers:
    a> Once one of the peers (it may be the server of the client) is done sending all its data, it calls AHKsock_Close to
       shutdown the socket. (It is not a good idea to have the last peer receiving data call AHKsock_Close. This will result
       in AHKsock_Send errors on the other peer if more data needs to be sent.) In the next steps, we refer to the peer that
       first calls AHKsock_Close as the invoker, and the other peer simply as the peer.
    b> The peer receives the invoker's intention to close the connection and is given one last chance to send any remaining
       data. This is when the peer's socket's associated function receives the SENDLAST event.
    c> Once the peer is done sending any remaining data (if any), it also calls AHKsock_Close on that same socket to shut it
       down, and then close the socket for good. This happens once the peer's function that received the SENDLAST event
       returns from the event. At this point, the peer's socket's associated function receives the DISCONNECTED event.
    d> This happens in parallel with c>. After the invoker receives the peer's final data (if any), as well as notice that
       the peer has also called AHKsock_Close on the socket, the invoker finally also closes the socket for good. At this
       point, the socket's associated function also receives the DISCONNECTED event.

When AHKsock_Close is called with no socket specified, this process occurs (in parallel) for every connected socket on
record.

____________________________________
NOTES ON RECEIVING AND SENDING DATA:

It's important to understand that AHKsock uses the TCP protocol, which is a stream protocol. This means that the data
received comes as a stream, with no apparent boundaries (i.e. frames or packets). For example, if a peer sends you a string,
it's possible that half the string is received in one RECEIVED event and the other half is received in the next. Of course,
the smaller the string, the less likely this happens. Conversely, the larger the string, the more likely this will occur.

Similarly, calling AHKsock_Send will not necessarily send the data right away. If multiple AHKsock_Send calls are issued,
Winsock might, under certain conditions, wait and accumulate data to send before sending it all at once. This process is
called coalescing. For example, if you send two strings to your peer by using two individual AHKsock_Send calls, the peer
will not necessarily receive two consecutive RECEIVED events for each string, but might instead receive both strings through
a single RECEIVED event.

One efficient method of receiving data as frames is to use length-prefixing. Length-prefixing means that before sending a
frame of variable length to your peer, you first tell it how many bytes will be in the frame. This way, your peer can
divide the received data into frames that can be individually processed. If it received less than a frame, it can store the
received data and wait for the remaining data to arrive before processing the completed frame with the length specified.
This technique is used in in AHKsock Example 3, where peers send each other strings by first declaring how long the string
will be (see the StreamProcessor function of Example 3).

____________________________________
NOTES ON TESTING A STREAM PROCESSOR:

As you write applications that use length-prefixing as described above, you might find it hard to test their ability to
properly cut up and/or put together the data into frames when testing them on the same machine or on a LAN (because the
latency is too low and it is thus harder to stress the connection).

In this case, what you can do to properly test them is to uncomment the comment block in AHKsock_Send, which will sometimes
purposely fail to send part of the data requested. This will allow you to simulate what could happen on a connection going
through the Internet. You may change the probability of failure by changing the number in the If statement.

If your application can still work after uncommenting the block, then it is a sign that it is properly handling frames split
across multiple RECEIVED events. This would also demonstrate your application's ability to cope with partially sent data.
*/

/****************\
 Main functions  |
               */

AHKsock_Listen(sPort, sFunction = False) {
    
    ;Check if there is already a socket listening on this port
    If (sktListen := AHKsock_Sockets("GetSocketFromNamePort", A_Space, sPort)) {
        
        ;Check if we're stopping the listening
        If Not sFunction {
            AHKsock_Close(sktListen) ;Close the socket
        
        ;Check if we're retrieving the current function
        } Else If (sFunction = "()") {
            Return AHKsock_Sockets("GetFunction", sktListen)
        
        ;Check if it's a different function
        } Else If (sFunction <> AHKsock_Sockets("GetFunction", sktListen))
            AHKsock_Sockets("SetFunction", sktListen, sFunction) ;Update it
        
        Return ;We're done
    }
    
    ;Make sure we even have a function
    If Not IsFunc(sFunction)
        Return 2 ;sFunction is not a valid function.
    
    ;Make sure Winsock has been started up
    If (i := AHKsock_Startup())
        Return (i = 1) ? 3 ;The WSAStartup() call failed. The error is in ErrorLevel.
                       : 4 ;The Winsock DLL does not support version 2.2.
    
    ;Resolve the local address and port to be used by the server
    VarSetCapacity(aiHints, 16 + 4 * A_PtrSize, 0)
    NumPut(1, aiHints,  0, "Int") ;ai_flags = AI_PASSIVE
    NumPut(2, aiHints,  4, "Int") ;ai_family = AF_INET
    NumPut(1, aiHints,  8, "Int") ;ai_socktype = SOCK_STREAM
    NumPut(6, aiHints, 12, "Int") ;ai_protocol = IPPROTO_TCP
    iResult := DllCall("Ws2_32\GetAddrInfo", "Ptr", 0, "Ptr", &sPort, "Ptr", &aiHints, "Ptr*", aiResult)
    If (iResult != 0) Or ErrorLevel { ;Check for error
        ErrorLevel := ErrorLevel ? ErrorLevel : iResult
        Return 5 ;The getaddrinfo() call failed. The error is in ErrorLevel.
    }
    
    sktListen := -1 ;INVALID_SOCKET
    sktListen := DllCall("Ws2_32\socket", "Int", NumGet(aiResult+0, 04, "Int")
                                        , "Int", NumGet(aiResult+0, 08, "Int")
                                        , "Int", NumGet(aiResult+0, 12, "Int"), "Ptr")
    If (sktListen = -1) Or ErrorLevel { ;Check for INVALID_SOCKET
        sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
        ErrorLevel := sErrorLevel
        Return 6 ;The socket() call failed. The error is in ErrorLevel.
    }
    
    ;Setup the TCP listening socket
    iResult := DllCall("Ws2_32\bind", "Ptr", sktListen, "Ptr", NumGet(aiResult+0, 16 + 2 * A_PtrSize), "Int", NumGet(aiResult+0, 16, "Ptr"))
    If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
        sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
        DllCall("Ws2_32\closesocket",  "Ptr", sktListen)
        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
        ErrorLevel := sErrorLevel
        Return 7 ;The bind() call failed. The error is in ErrorLevel.
    }
    
    DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
    
    ;Add socket to array with A_Space for Name and IP to indicate that it's a listening socket
    AHKsock_Sockets("Add", sktListen, A_Space, A_Space, sPort, sFunction)
    
    ;We must now actually register the socket
    If AHKsock_RegisterAsyncSelect(sktListen) {
        sErrorLevel := ErrorLevel
        DllCall("Ws2_32\closesocket", "Ptr", sktListen)
        AHKsock_Sockets("Delete", sktListen) ;Remove from array
        ErrorLevel := sErrorLevel
        Return 8 ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.
    }
    
    ;Start listening for incoming connections
    iResult := DllCall("Ws2_32\listen", "Ptr", sktListen, "Int", 0x7FFFFFFF) ;SOMAXCONN
    If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
        sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
        DllCall("Ws2_32\closesocket", "Ptr", sktListen)
        AHKsock_Sockets("Delete", sktListen) ;Remove from array
        ErrorLevel := sErrorLevel
        Return 9 ;The listen() call failed. The error is in ErrorLevel.
    }
}

AHKsock_Connect(sName, sPort, sFunction) {
    Static aiResult, iPointer, bProcessing, iMessage
    Static sCurName, sCurPort, sCurFunction, sktConnect
    
    ;Check if it's just to inquire whether or not a call is possible
    If (Not sName And Not sPort And Not sFunction)
        Return bProcessing
    
    ;Check if we're busy
    If bProcessing And (sFunction != iMessage) {
        ErrorLevel := sCurName A_Tab sCurPort
        Return 1 ;AHKsock_Connect is still processing a connection attempt. ErrorLevel contains the name and the port,
                 ;delimited by a tab.
    } Else If bProcessing { ;sFunction = iMessage. The connect operation has finished.
        
        ;Check if it was successful
        If (i := sPort >> 16) {
            
            ;Close the socket that failed
            DllCall("Ws2_32\closesocket", "Ptr", sktConnect)
            
            ;Get the next pointer. ai_next
            iPointer := NumGet(iPointer+0, 16 + 3 * A_PtrSize)
            
            ;Check if we reached the end of the linked structs
            If (iPointer = 0) {
                
                ;We can now free the chain of addrinfo structs
                DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
                
                ;This is to ensure that the user can call AHKsock_Connect() right away upon receiving the message.
                bProcessing := False
                
                ;Raise an error (can't use Return 1 because we were called asynchronously)
                ErrorLevel := i
                AHKsock_RaiseError(1) ;The connect() call failed. The error is in ErrorLevel.
                
                ;Call the function to signal that connection failed
                If IsFunc(sCurFunction)
                    %sCurFunction%("CONNECTED", -1, sCurName, 0, sCurPort)
                
                Return
            }
            
        } Else { ;Successful connection!
            
            ;Get the IP we successfully connected to
            sIP := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(NumGet(iPointer+0, 16 + 2 * A_PtrSize)+4, 0, "UInt"), "AStr")
            
            ;We can now free the chain of ADDRINFO structs
            DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
            
            ;Add socket to array
            AHKsock_Sockets("Add", sktConnect, sCurName, sIP, sCurPort, sCurFunction)
            
            ;This is to ensure that the user can call AHKsock_Connect() right away upon receiving the message.
            bProcessing := False
            
            ;Do this small bit in Critical so that AHKsock_AsyncSelect doesn't receive
            ;any FD messages before we call the user function
            Critical
            
            ;We must now actually register the socket
            If AHKsock_RegisterAsyncSelect(sktConnect) {
                sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
                DllCall("Ws2_32\closesocket", "Ptr", sktConnect)
                AHKsock_Sockets("Delete", sktConnect) ;Remove from array
                ErrorLevel := sErrorLevel
                AHKsock_RaiseError(2) ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.
                
                If IsFunc(sCurFunction) ;Call the function to signal that connection failed
                    %sCurFunction%("CONNECTED", -1, sCurName, 0, sCurPort)
                
            } Else If IsFunc(sCurFunction) ;Call the function to signal that connection was successful
                %sCurFunction%("CONNECTED", sktConnect, sCurName, sIP, sCurPort)
            
            Return
        }
        
    } Else { ;We were called
        
        ;Make sure we even have a function
        If Not IsFunc(sFunction)
            Return 2 ;sFunction is not a valid function.
        
        bProcessing := True ;Block future calls to AHKsock_Connect() until we're done
        
        ;Keep the values
        sCurName := sName
        sCurPort := sPort
        sCurFunction := sFunction
        
        ;Make sure Winsock has been started up
        If (i := AHKsock_Startup()) {
            bProcessing := False
            Return (i = 1) ? 3 ;The WSAStartup() call failed. The error is in ErrorLevel.
                           : 4 ;The Winsock DLL does not support version 2.2.
        }
        
        ;Resolve the server address and port    
        VarSetCapacity(aiHints, 16 + 4 * A_PtrSize, 0)
        NumPut(2, aiHints,  4, "Int") ;ai_family = AF_INET
        NumPut(1, aiHints,  8, "Int") ;ai_socktype = SOCK_STREAM
        NumPut(6, aiHints, 12, "Int") ;ai_protocol = IPPROTO_TCP
        iResult := DllCall("Ws2_32\GetAddrInfo", "Ptr", &sName, "Ptr", &sPort, "Ptr", &aiHints, "Ptr*", aiResult)
        If (iResult != 0) Or ErrorLevel { ;Check for error
            ErrorLevel := ErrorLevel ? ErrorLevel : iResult
            bProcessing := False
            Return 5 ;The getaddrinfo() call failed. The error is in ErrorLevel.
        }
        
        ;Start with the first struct
        iPointer := aiResult
    }
    
    ;Create a SOCKET for connecting to server
    sktConnect := DllCall("Ws2_32\socket", "Int", NumGet(iPointer+0, 04, "Int")
                                         , "Int", NumGet(iPointer+0, 08, "Int")
                                         , "Int", NumGet(iPointer+0, 12, "Int"), "Ptr")
    If (sktConnect = 0xFFFFFFFF) Or ErrorLevel { ;Check for INVALID_SOCKET
        sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
        bProcessing := False
        ErrorLevel := sErrorLevel
        If (sFunction = iMessage) { ;Check if we were called asynchronously
            AHKsock_RaiseError(3) ;The socket() call failed. The error is in ErrorLevel.
            
            ;Call the function to signal that connection failed
            If IsFunc(sCurFunction)
                %sCurFunction%("CONNECTED", -1)
        }
        Return 6 ;The socket() call failed. The error is in ErrorLevel.
    }
    
    ;Register the socket to know when the connect() function is done. FD_CONNECT = 16
    iMessage := AHKsock_Settings("Message") + 1
    If AHKsock_RegisterAsyncSelect(sktConnect, 16, "AHKsock_Connect", iMessage) {
        sErrorLevel := ErrorLevel
        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
        DllCall("Ws2_32\closesocket",  "Ptr", sktConnect)
        bProcessing := False
        ErrorLevel := sErrorLevel
        If (sFunction = iMessage) { ;Check if we were called asynchronously
            AHKsock_RaiseError(4) ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.
            
            ;Call the function to signal that connection failed
            If IsFunc(sCurFunction)
                %sCurFunction%("CONNECTED", -1)
        }
        Return 7 ;The WSAAsyncSelect() call failed. The error is in ErrorLevel.
    }
    
    ;Connect to server (the connect() call also implicitly binds the socket to any host address and any port)
    iResult := DllCall("Ws2_32\connect", "Ptr", sktConnect, "Ptr", NumGet(iPointer+0, 16 + 2 * A_PtrSize), "Int", NumGet(iPointer+0, 16))
    If ErrorLevel Or ((iResult = -1) And (AHKsock_LastError() != 10035)) { ;Check for any error other than WSAEWOULDBLOCK
        sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
        DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
        DllCall("Ws2_32\closesocket",  "Ptr", sktConnect)
        bProcessing := False
        ErrorLevel := sErrorLevel
        If (sFunction = iMessage) { ;Check if we were called asynchronously
            AHKsock_RaiseError(5) ;The connect() call failed. The error is in ErrorLevel.
            
            ;Call the function to signal that connection failed
            If IsFunc(sCurFunction)
                %sCurFunction%("CONNECTED", -1)
        }
        Return 8 ;The connect() call failed. The error is in ErrorLevel.
    }
}

AHKsock_Send(iSocket, ptrData = 0, iLength = 0) {
    
    ;Make sure the socket is on record. Fail-safe
    If Not AHKsock_Sockets("Index", iSocket)
        Return -4 ;The socket specified in iSocket is not a recognized socket.
    
    ;Make sure Winsock has been started up
    If Not AHKsock_Startup(1)
        Return -1 ;WSAStartup hasn't been called yet.
    
    ;Make sure the socket is cleared for sending
    If Not AHKsock_Sockets("GetSend", iSocket)
        Return -5 ;The socket specified in iSocket is not cleared for sending.
    
    /*! Uncomment this block to simulate the possibility of an incomplete send()
    Random, iRand, 1, 100
    If (iRand <= 30) { ;Probability of failure of 30%
        Random, iRand, 1, iLength - 1 ;Randomize how much of the data will not be sent
        iLength -= iRand
    }
    */
    
    iSendResult := DllCall("Ws2_32\send", "Ptr", iSocket, "Ptr", ptrData, "Int", iLength, "Int", 0)
    If (iSendResult = -1) And ((iErr := AHKsock_LastError()) = 10035) { ;Check specifically for WSAEWOULDBLOCK
        AHKsock_Sockets("SetSend", iSocket, False) ;Update socket's send status
        Return -2 ;Calling send() would have blocked the thread. Try again once you get the proper update.
    } Else If (iSendResult = -1) Or ErrorLevel {
        ErrorLevel := ErrorLevel ? ErrorLevel : iErr
        Return -3 ;The send() call failed. The error is in ErrorLevel.
    } Else Return iSendResult ;The send() operation was successful
}

AHKsock_ForceSend(iSocket, ptrData, iLength) {
    
    ;Make sure Winsock has been started up
    If Not AHKsock_Startup(1)
        Return -1 ;WSAStartup hasn't been called yet
    
    ;Make sure the socket is on record. Fail-safe
    If Not AHKsock_Sockets("Index", iSocket)
        Return -4
    
    ;Make sure that we're not in Critical, or we won't be able to wait for FD_WRITE messages
    If A_IsCritical
        Return -5
    
    ;Extra precaution to make sure FD_WRITE messages can make it
    Thread, Priority, 0
    
    ;We need to make sure not to fill up the send buffer in one call, or we'll get a performance hit.
    ;http://support.microsoft.com/kb/823764
    
    ;Get the socket's send buffer size
    If ((iMaxChunk := AHKsock_SockOpt(iSocket, "SO_SNDBUF")) = -1)
        Return -6
    
    ;Check if we'll be sending in chunks or not
    If (iMaxChunk <= 1) {
        
        ;We'll be sending as much as possible everytime!
        
        Loop { ;Keep sending the data until we're done or until an error occurs
            
            ;Wait until we can send data (ie. when FD_WRITE arrives)
            While Not AHKsock_Sockets("GetSend", iSocket)
                Sleep -1
            
            Loop { ;Keep sending the data until we get WSAEWOULDBLOCK or until an error occurs
                If ((iSendResult := AHKsock_Send(iSocket, ptrData, iLength)) < 0) {
                    If (iSendResult = -2) ;Check specifically for WSAEWOULDBLOCK
                        Break ;Calling send() would have blocked the thread. Break the loop and we'll try again after we
                              ;receive FD_WRITE
                    Else Return iSendResult ;Something bad happened with AHKsock_Send. Return the same value we got.
                } Else {
                    
                    ;AHKsock_Send was able to send bytes. Let's check if it sent only part of what we requested
                    If (iSendResult < iLength) ;Move the offset up by what we were able to send
                        ptrData += iSendResult, iLength -= iSendResult
                    Else Return ;We're done sending all the data
                }
            }
        }
    } Else {
        
        ;We'll be sending in chunks of just under the send buffer size to avoid the performance hit
        
        iMaxChunk -= 1 ;Reduce by 1 to be smaller than the send buffer
        Loop { ;Keep sending the data until we're done or until an error occurs
            
            ;Wait until we can send data (ie. when FD_WRITE arrives)
            While Not AHKsock_Sockets("GetSend", iSocket)
                Sleep -1
            
            ;Check if we have less than the max chunk to send
            If (iLength < iMaxChunk) {
                
                Loop { ;Keep sending the data until we get WSAEWOULDBLOCK or until an error occurs
                    ;Send using the traditional offset method
                    If ((iSendResult := AHKsock_Send(iSocket, ptrData, iLength)) < 0) {
                        If (iSendResult = -2) ;Check specifically for WSAEWOULDBLOCK
                            Break ;Calling send() would have blocked the thread. Break the loop and we'll try again after we
                                  ;receive FD_WRITE
                        Else Return iSendResult ;Something bad happened with AHKsock_Send. Return the same value we got.
                    } Else {
                        
                        ;AHKsock_Send was able to send bytes. Let's check if it sent only part of what we requested
                        If (iSendResult < iLength) ;Move the offset up by what we were able to send
                            ptrData += iSendResult, iLength -= iSendResult
                        Else Return ;We're done sending all the data
                    }
                }
            } Else {
                
                ;Send up to max chunk
                If ((iSendResult := AHKsock_Send(iSocket, ptrData, iMaxChunk)) < 0) {
                    If (iSendResult = -2) ;Check specifically for WSAEWOULDBLOCK
                        Continue ;Calling send() would have blocked the thread. Continue the loop and we'll try again after
                                 ;we receive FD_WRITE
                    Else Return iSendResult ;Something bad happened with AHKsock_Send. Return the same value we got.
                } Else ptrData += iSendResult, iLength -= iSendResult ;Move up offset by updating the pointer and length
            }
        }
    }
}

AHKsock_Close(iSocket = -1, iTimeout = 5000) {
    
    ;Make sure Winsock has been started up
    If Not AHKsock_Startup(1)
        Return ;There's nothing to close
    
    If (iSocket = -1) { ;We need to close all the sockets
        
        ;Check if we even have sockets to close
        If Not AHKsock_Sockets() {
            DllCall("Ws2_32\WSACleanup")
            AHKsock_Startup(2) ;Reset the value to show that we've turned off Winsock
            Return ;We're done!
        }
        
        ;Take the current time (needed for time-outing)
        iStartClose := A_TickCount
        
        Loop % AHKsock_Sockets() ;Close all sockets and cleanup
            AHKsock_ShutdownSocket(AHKsock_Sockets("GetSocketFromIndex", A_Index))
        
        ;Check if we're in the OnExit subroutine
        If Not A_ExitReason {
            
            A_IsCriticalOld := A_IsCritical
            
            ;Make sure we can still receive FD_CLOSE msgs
            Critical, Off
            Thread, Priority, 0
            
            ;We can try a graceful shutdown or wait for a timeout
            While (AHKsock_Sockets()) And (A_TickCount - iStartClose < iTimeout)
                Sleep, -1
            
            ;Restore previous Critical
            Critical, %A_IsCriticalOld%
        }
        
        /*! Used for debugging purposes only
        If (i := AHKsock_Sockets()) {
            If (i = 1)
                OutputDebug, % "Cleaning up now, with the socket " AHKsock_Sockets("GetSocketFromIndex", 1) " remaining..."
            Else {
                OutputDebug, % "Cleaning up now, with the following sockets remaining:"
                Loop % AHKsock_Sockets() {
                    OutputDebug, % AHKsock_Sockets("GetSocketFromIndex", A_Index)
                }
            }
        }
        */
        
        DllCall("Ws2_32\WSACleanup")
        AHKsock_Startup(2) ;Reset the value to show that we've turned off Winsock
        
    ;Close only one socket
    } Else If AHKsock_ShutdownSocket(iSocket) ;Error-checking
        Return 1 ;The shutdown() call failed. The error is in ErrorLevel.
}

AHKsock_GetAddrInfo(sHostName, ByRef sIPList, bOne = False) {
    
    ;Make sure Winsock has been started up
    If (i := AHKsock_Startup())
        Return i ;Return the same error (error 1 and 2)
    
    ;Resolve the address and port    
    VarSetCapacity(aiHints, 16 + 4 * A_PtrSize, 0)
    NumPut(2, aiHints,  4, "Int") ;ai_family = AF_INET
    NumPut(1, aiHints,  8, "Int") ;ai_socktype = SOCK_STREAM
    NumPut(6, aiHints, 12, "Int") ;ai_protocol = IPPROTO_TCP
    iResult := DllCall("Ws2_32\GetAddrInfo", "Ptr", &sHostName, "Ptr", 0, "Ptr", &aiHints, "Ptr*", aiResult)
    If (iResult = 11001) ;Check specifically for WSAHOST_NOT_FOUND since it's the most common error
        Return 3 ;Received WSAHOST_NOT_FOUND. No such host is known.
    Else If (iResult != 0) Or ErrorLevel { ;Check for any other error
        ErrorLevel := ErrorLevel ? ErrorLevel : iResult
        Return 4 ;The getaddrinfo() call failed. The error is in ErrorLevel.
    }
    
    If bOne
        sIPList := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(NumGet(aiResult+0, 16 + 2 * A_PtrSize)+4, 0, "UInt"), "AStr")
    Else {
        
        ;Start with the first addrinfo struct
        iPointer := aiResult, sIPList := ""
        While iPointer {
            s := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(NumGet(iPointer+0, 16 + 2 * A_PtrSize)+4, 0, "UInt"), "AStr")
            iPointer := NumGet(iPointer+0, 16 + 3 * A_PtrSize) ;Go to the next addrinfo struct
            sIPList .=  s (iPointer ? "`n" : "") ;Add newline only if it's not the last one
        }
    }
    
    ;We're done
    DllCall("Ws2_32\FreeAddrInfo", "Ptr", aiResult)
}

AHKsock_GetNameInfo(sIP, ByRef sHostName, sPort = 0, ByRef sService = "") {
    
    ;Make sure Winsock has been started up
    If (i := AHKsock_Startup())
        Return i ;Return the same error (error 1 and 2)
    
    ;Translate to IN_ADDR
    iIP := DllCall("Ws2_32\inet_addr", "AStr", sIP, "UInt")
    If (iIP = 0 Or iIP = 0xFFFFFFFF) ;Check for INADDR_NONE or INADDR_ANY
        Return 3 ;The IP address supplied in sIP is invalid.
    
    ;Construct a sockaddr struct
    VarSetCapacity(tSockAddr, 16, 0)
    NumPut(2,   tSockAddr, 0, "Short") ;ai_family = AF_INET
    NumPut(iIP, tSockAddr, 4, "UInt") ;Put in the IN_ADDR
    
    ;Fill in the port field if we're also looking up the service name
    If sPort           ;Translate to network byte order
        NumPut(DllCall("Ws2_32\htons", "UShort", sPort, "UShort"), tSockAddr, 2, "UShort")
    
    ;Prep vars
    VarSetCapacity(sHostName, 1025 * 2, 0) ;NI_MAXHOST
    If sPort
        VarSetCapacity(sService, 32 * 2, 0) ;NI_MAXSERV
    
    iResult := DllCall("Ws2_32\GetNameInfoW", "Ptr", &tSockAddr, "Int", 16, "Str", sHostName, "UInt", 1025 * 2
                                           , sPort ? "Str" : "UInt", sPort ? sService : 0, "UInt", 32 * 2, "Int", 0)
    If (iResult != 0) Or ErrorLevel {
        ErrorLevel := ErrorLevel ? ErrorLevel : DllCall("Ws2_32\WSAGetLastError")
        Return 4 ;The getnameinfo() call failed. The error is in ErrorLevel.
    }
}

AHKsock_SockOpt(iSocket, sOption, iValue = -1) {
    
    ;Prep variable
    VarSetCapacity(iOptVal, iOptValLength := 4, 0)
    If (iValue <> -1)
        NumPut(iValue, iOptVal, 0, "UInt")
    
    If (sOption = "SO_KEEPALIVE") {
        intLevel := 0xFFFF ;SOL_SOCKET
        intOptName := 0x0008 ;SO_KEEPALIVE
    } Else If (sOption = "SO_SNDBUF") {
        intLevel := 0xFFFF ;SOL_SOCKET
        intOptName := 0x1001 ;SO_SNDBUF
    } Else If (sOption = "SO_RCVBUF") {
        intLevel := 0xFFFF ;SOL_SOCKET
        intOptName := 0x1002 ;SO_SNDBUF
    } Else If (sOption = "TCP_NODELAY") {
        intLevel := 6 ;IPPROTO_TCP
        intOptName := 0x0001 ;TCP_NODELAY
    }
    
    ;Check if we're getting or setting
    If (iValue = -1) {
        iResult := DllCall("Ws2_32\getsockopt", "Ptr", iSocket, "Int", intLevel, "Int", intOptName
                                              , "UInt*", iOptVal, "Int*", iOptValLength)
        If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
            ErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
            Return -1
        } Else Return iOptVal
    } Else {
        iResult := DllCall("Ws2_32\setsockopt", "Ptr", iSocket, "Int", intLevel, "Int", intOptName
                                              , "Ptr", &iOptVal, "Int",  iOptValLength)
        If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
            ErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
            Return -2
        }
    }
}

/*******************\
 Support functions  |
                  */

AHKsock_Startup(iMode = 0) {
    Static bAlreadyStarted
    
    /*
    iMode = 0 ;Turns on WSAStartup()
    iMode = 1 ;Returns whether or not WSAStartup has been called
    iMode = 2 ;Resets the static variable to force another call next time iMode = 0
    */
    
    If (iMode = 2)
        bAlreadyStarted := False
    Else If (iMode = 1)
        Return bAlreadyStarted
    Else If Not bAlreadyStarted { ;iMode = 0. Call the function only if it hasn't already been called.
        
        ;Start it up - request version 2.2
        VarSetCapacity(wsaData, A_PtrSize = 4 ? 400 : 408, 0)
        iResult := DllCall("Ws2_32\WSAStartup", "UShort", 0x0202, "Ptr", &wsaData)
        If (iResult != 0) Or ErrorLevel {
            ErrorLevel := ErrorLevel ? ErrorLevel : iResult
            Return 1
        }
        
        ;Make sure the Winsock DLL supports at least version 2.2
        If (NumGet(wsaData, 2, "UShort") < 0x0202) {
            DllCall("Ws2_32\WSACleanup") ;Abort
            ErrorLevel := "The Winsock DLL does not support version 2.2."
            Return 2
        }
        
        bAlreadyStarted := True
    }
}

AHKsock_ShutdownSocket(iSocket) {
    
    ;Check if it's a listening socket
    sName := AHKsock_Sockets("GetName", iSocket)
    If (sName != A_Space) { ;It's not a listening socket. Shutdown send operations.
        iResult := DllCall("Ws2_32\shutdown", "Ptr", iSocket, "Int", 1) ;SD_SEND
        If (iResult = -1) Or ErrorLevel {
            sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
            DllCall("Ws2_32\closesocket", "Ptr", iSocket)
            AHKsock_Sockets("Delete", iSocket)
            ErrorLevel := sErrorLevel
            Return 1
        }
        
        ;Mark it
        AHKsock_Sockets("SetShutdown", iSocket)
        
    } Else {
        DllCall("Ws2_32\closesocket", "Ptr", iSocket) ;It's only a listening socket
        AHKsock_Sockets("Delete", iSocket) ;Remove it from the array
    }
}

/***********************\
 AsyncSelect functions  |
                      */
                                     ;FD_READ | FD_WRITE | FD_ACCEPT | FD_CLOSE
AHKsock_RegisterAsyncSelect(iSocket, fFlags = 43, sFunction = "AHKsock_AsyncSelect", iMsg = 0) {
    Static hwnd := False
    
    If Not hwnd { ;Use the main AHK window
        A_DetectHiddenWindowsOld := A_DetectHiddenWindows
        DetectHiddenWindows, On
        WinGet, hwnd, ID, % "ahk_pid " DllCall("GetCurrentProcessId") " ahk_class AutoHotkey"
        DetectHiddenWindows, %A_DetectHiddenWindowsOld%
    }
    
    iMsg := iMsg ? iMsg : AHKsock_Settings("Message")
    If (OnMessage(iMsg) <> sFunction)
        OnMessage(iMsg, sFunction)
    
    iResult := DllCall("Ws2_32\WSAAsyncSelect", "Ptr", iSocket, "Ptr", hwnd, "UInt", iMsg, "Int", fFlags)
    If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
        ErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
        Return 1
    }
}

AHKsock_AsyncSelect(wParam, lParam) {
    Critical ;So that messages are buffered
    
    ;wParam parameter identifies the socket on which a network event has occurred
    ;The low word of lParam specifies the network event that has occurred.
    ;The high word of lParam contains any error code
    
    ;Make sure the socket is on record. Fail-safe
    If Not AHKsock_Sockets("Index", wParam)
        Return
    
    iEvent := lParam & 0xFFFF, iErrorCode := lParam >> 16
    
    /*! Used for debugging purposes
    OutputDebug, % "AsyncSelect - A network event " iEvent " has occurred on socket " wParam
    If iErrorCode
        OutputDebug, % "AsyncSelect - Error code = " iErrorCode
    */
    
    If (iEvent = 1) { ;FD_READ
        
        ;Check for error
        If iErrorCode { ;WSAENETDOWN is the only possible
            ErrorLevel := iErrorCode
            ;FD_READ event received with an error. The error is in ErrorLevel. The socket is in iSocket.
            AHKsock_RaiseError(6, wParam)
            Return
        }
        
        VarSetCapacity(bufReceived, bufReceivedLength := AHKsock_Settings("Buffer"), 0)
        iResult := DllCall("Ws2_32\recv", "UInt", wParam, "Ptr", &bufReceived, "Int", bufReceivedLength, "Int", 0)
        If (iResult > 0) { ;We received data!
            VarSetCapacity(bufReceived, -1) ;Update the internal length
            
            ;Get associated function and call it
            If IsFunc(sFunc := AHKsock_Sockets("GetFunction", wParam))
                %sFunc%("RECEIVED", wParam, AHKsock_Sockets("GetName", wParam)
                                          , AHKsock_Sockets("GetAddr", wParam)
                                          , AHKsock_Sockets("GetPort", wParam), bufReceived, iResult)
            
        ;Check for error other than WSAEWOULDBLOCK
        } Else If ErrorLevel Or ((iResult = -1) And Not ((iErrorCode := AHKsock_LastError()) = 10035)) {
            ErrorLevel := ErrorLevel ? ErrorLevel : iErrorCode
            AHKsock_RaiseError(7, wParam) ;The recv() call failed. The error is in ErrorLevel. The socket is in iSocket.
            iResult = -1 ;So that if it's a spoofed call from FD_CLOSE, we exit the loop and close the socket
        }
        
        ;Here, we bother with returning a value in case it's a spoofed call from FD_CLOSE
        Return iResult
        
    } Else If (iEvent = 2) { ;FD_WRITE
        
        ;Check for error
        If iErrorCode { ;WSAENETDOWN is the only possible
            ErrorLevel := iErrorCode
            ;FD_WRITE event received with an error. The error is in ErrorLevel. The socket is in iSocket.
            AHKsock_RaiseError(8, wParam)
            Return
        }
        
        ;Update socket's setting
        AHKsock_Sockets("SetSend", wParam, True)
        
        ;Make sure the socket isn't already shut down
        If Not AHKsock_Sockets("GetShutdown", wParam)
            If IsFunc(sFunc := AHKsock_Sockets("GetFunction", wParam))
                %sFunc%("SEND", wParam, AHKsock_Sockets("GetName", wParam)
                                      , AHKsock_Sockets("GetAddr", wParam)
                                      , AHKsock_Sockets("GetPort", wParam))
        
    } Else If (iEvent = 8) { ;FD_ACCEPT
        
        ;Check for error
        If iErrorCode { ;WSAENETDOWN is the only possible
            ErrorLevel := iErrorCode
            ;FD_ACCEPT event received with an error. The error is in ErrorLevel. The socket is in iSocket.
            AHKsock_RaiseError(9, wParam)
            Return
        }
        
        ;We need to accept the connection
        VarSetCapacity(tSockAddr, tSockAddrLength := 16, 0)
        sktClient := DllCall("Ws2_32\accept", "Ptr", wParam, "Ptr", &tSockAddr, "Int*", tSockAddrLength)
        If (sktClient = -1) And ((iErrorCode := AHKsock_LastError()) = 10035) ;Check specifically for WSAEWOULDBLOCK
            Return ;We'll be called again next time we can retry accept()
        Else If (sktClient = -1) Or ErrorLevel { ;Check for INVALID_SOCKET
            ErrorLevel := ErrorLevel ? ErrorLevel : iErrorCode
            ;The accept() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
            AHKsock_RaiseError(10, wParam)
            Return
        }
        
        ;Add to array
        sName := ""
        sAddr := DllCall("Ws2_32\inet_ntoa", "UInt", NumGet(tSockAddr, 4, "UInt"), "AStr")
        sPort := AHKsock_Sockets("GetPort", wParam)
        sFunc := AHKsock_Sockets("GetFunction", wParam)
        AHKsock_Sockets("Add", sktClient, sName, sAddr, sPort, sFunc)
        
        ;Go back to listening
        iResult := DllCall("Ws2_32\listen", "Ptr", wParam, "Int", 0x7FFFFFFF) ;SOMAXCONN       
        If (iResult = -1) Or ErrorLevel { ;Check for SOCKET_ERROR
            sErrorLevel := ErrorLevel ? ErrorLevel : AHKsock_LastError()
            DllCall("Ws2_32\closesocket", "Ptr", wParam)
            AHKsock_Sockets("Delete", wParam) ;Remove from array
            ErrorLevel := sErrorLevel
            ;The listen() call failed. The error is in ErrorLevel. The listening socket is in iSocket.
            AHKsock_RaiseError(12, wParam)
            Return
        }
        
        ;Get associated function and call it
        If IsFunc(sFunc)
            %sFunc%("ACCEPTED", sktClient, sName, sAddr, sPort)
        
    } Else If (iEvent = 32) { ;FD_CLOSE
        
        ;Keep receiving data before closing the socket by spoofing an FD_READ event to call recv()
        While (AHKsock_AsyncSelect(wParam, 1) > 0)
            Sleep, -1
        
        ;Check if we initiated it
        If Not AHKsock_Sockets("GetShutdown", wParam) {
            
            ;Last chance to send data. Get associated function and call it.
            If IsFunc(sFunc := AHKsock_Sockets("GetFunction", wParam))
                %sFunc%("SENDLAST", wParam, AHKsock_Sockets("GetName", wParam)
                                          , AHKsock_Sockets("GetAddr", wParam)
                                          , AHKsock_Sockets("GetPort", wParam))
            
            ;Shutdown the socket. This is to attempt a graceful shutdown
            If AHKsock_ShutdownSocket(wParam) {
                ;The shutdown() call failed. The error is in ErrorLevel. The socket is in iSocket.
                AHKsock_RaiseError(13, wParam)
                Return
            }
        }
        
        ;We just have to close the socket then
        DllCall("Ws2_32\closesocket", "Ptr", wParam)
        
        ;Get associated data before deleting
        sFunc := AHKsock_Sockets("GetFunction", wParam)
        sName := AHKsock_Sockets("GetName", wParam)
        sAddr := AHKsock_Sockets("GetAddr", wParam)
        sPort := AHKsock_Sockets("GetPort", wParam)
        
        ;We can remove it from the array
        AHKsock_Sockets("Delete", wParam)
        
        If IsFunc(sFunc)
            %sFunc%("DISCONNECTED", wParam, sName, sAddr, sPort)
    }
}

/******************\
 Array controller  |
                 */

AHKsock_Sockets(sAction = "Count", iSocket = "", sName = "", sAddr = "", sPort = "", sFunction = "") {
    Static
    Static aSockets0 := 0
    Static iLastSocket := 0xFFFFFFFF ;Cache to lessen index lookups on the same socket
    Local i, ret, A_IsCriticalOld
    
    A_IsCriticalOld := A_IsCritical
    Critical
    
    If (sAction = "Count") {
        ret := aSockets0
        
    } Else If (sAction = "Add") {
        aSockets0 += 1 ;Expand array
        aSockets%aSockets0%_Sock := iSocket
        aSockets%aSockets0%_Name := sName
        aSockets%aSockets0%_Addr := sAddr
        aSockets%aSockets0%_Port := sPort
        aSockets%aSockets0%_Func := sFunction
        aSockets%aSockets0%_Shutdown := False
        aSockets%aSockets0%_Send := False
        
    } Else If (sAction = "Delete") {
        
        ;First we need the index
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        
        If i {
            iLastSocket := 0xFFFF ;Clear cache
            If (i < aSockets0) { ;Let the last item overwrite this one
                aSockets%i%_Sock := aSockets%aSockets0%_Sock
                aSockets%i%_Name := aSockets%aSockets0%_Name
                aSockets%i%_Addr := aSockets%aSockets0%_Addr
                aSockets%i%_Port := aSockets%aSockets0%_Port
                aSockets%i%_Func := aSockets%aSockets0%_Func
                aSockets%i%_Shutdown := aSockets%aSockets0%_Shutdown
                aSockets%i%_Send := aSockets%aSockets0%_Send
                
            }
            aSockets0 -= 1 ;Remove element
        }
        
    } Else If (sAction = "GetName") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        ret := aSockets%i%_Name
        
    } Else If (sAction = "GetAddr") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        ret := aSockets%i%_Addr
        
    } Else If (sAction = "GetPort") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        ret := aSockets%i%_Port
        
    } Else If (sAction = "GetFunction") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        ret := aSockets%i%_Func
        
    } Else If (sAction = "SetFunction") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        aSockets%i%_Func := sName
        
    } Else If (sAction = "GetSend") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        ret := aSockets%i%_Send
        
    } Else If (sAction = "SetSend") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        aSockets%i%_Send := sName
        
    } Else If (sAction = "GetShutdown") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        ret := aSockets%i%_Shutdown
        
    } Else If (sAction = "SetShutdown") {
        i := (iSocket = iLastSocket) ;Check cache
        ? iLastSocketIndex
        : AHKsock_Sockets("Index", iSocket)
        aSockets%i%_Shutdown := True
        
    } Else If (sAction = "GetSocketFromNamePort") {
        Loop % aSockets0 {
            If (aSockets%A_Index%_Name = iSocket)
            And (aSockets%A_Index%_Port = sName) {
                ret := aSockets%A_Index%_Sock
                Break
            }
        }
        
    } Else If (sAction = "GetSocketFromIndex") {
        ret := aSockets%iSocket%_Sock
    
    } Else If (sAction = "Index") {
        Loop % aSockets0 {
            If (aSockets%A_Index%_Sock = iSocket) {
                iLastSocketIndex := A_Index, iLastSocket := iSocket
                ret := A_Index
                Break
            }
        }
    }
    
    ;Restore old Critical setting
    Critical %A_IsCriticalOld%
    Return ret
}

/*****************\
 Error Functions  |
                */

AHKsock_LastError() {
    Return DllCall("Ws2_32\WSAGetLastError")
}

AHKsock_ErrorHandler(sFunction = """") {
    Static sCurrentFunction
    If (sFunction = """")
        Return sCurrentFunction
    Else sCurrentFunction := sFunction
}

AHKsock_RaiseError(iError, iSocket = -1) {
    If IsFunc(sFunc := AHKsock_ErrorHandler())
        %sFunc%(iError, iSocket)
}

/*******************\
 Settings Function  |
                  */

AHKsock_Settings(sSetting, sValue = "") {
    Static iMessage := 0x8000
    Static iBuffer := 65536
    
    If (sSetting = "Message") {
        If Not sValue
            Return iMessage
        Else iMessage := (sValue = "Reset") ? 0x8000 : sValue
    } Else If (sSetting = "Buffer") {
        If Not sValue
            Return iBuffer
        Else iBuffer := (sValue = "Reset") ? 65536 : sValue
    }
}

/*
Crypt class
	Currently Contains two classes and different methods for encryption and hashing
Classes:
	Crypt.Encrypt - Encryption class
	Crypt.Hash - Hashing class
=====================================================================
Methods:
=====================================================================
Crypt.Encrypt.FileEncrypt(pFileIn,pFileOut,password,CryptAlg = 1, HashAlg = 1)
	Encrypts the file
Parameters:
	pFileIn - path to file which to encrypt
	pFileOut - path to save encrypted file
	password - no way, it's just a password...
	(optional) CryptAlg - Encryption algorithm ID, for details see below
	(optional) HashAlg - hashing algorithm ID, for details see below
Return:
	on success, - Number of bytes writen to pFileOut
	on fail, - ""
--------
Crypt.Encrypt.FileDecrypt(pFileIn,pFileOut,password,CryptAlg = 1, HashAlg = 1)
	Decrypts the file, the parameters are identical to FileEncrypt,	except:
	pFileIn - path to encrypted file which to decrypt
	pFileOut - path to save decrypted file
=====================================================================
Crypt.Encrypt.StrEncrypt(string,password,CryptAlg = 1, HashAlg = 1)
	Encrypts the string
Parameters:
	string - UTF string, means any string you use in AHK_L Unicode
	password - no way, it's just a password...
	(optional) CryptAlg - Encryption algorithm ID, for details see below
	(optional) HashAlg - hashing algorithm ID, for details see below
Return:
	on success, - HASH representaion of encrypted buffer, which is easily transferable. 
				You can get actual encrypted buffer from HASH by using function HashToByte()
	on fail, - ""	
--------
Crypt.Encrypt.StrDecrypt(EncryptedHash,password,CryptAlg = 1, HashAlg = 1)
	Decrypts the string, the parameters are identical to StrEncrypt,	except:
	EncryptedHash - hash string returned by StrEncrypt()
=====================================================================
Crypt.Hash.FileHash(pFile,HashAlg = 1,pwd = "",hmac_alg = 1)
--------
	Gets the HASH of file
Parameters:
	pFile - path to file which hash will be calculated
	(optional) HashAlg - hashing algorithm ID, for details see below
	(optional) pwd - password, if present - the hashing algorith will use HMAC to calculate hash
	(optional) hmac_alg - Encryption algorithm ID of HMAC key, will be used if pwd parameter present
Return:
	on success, - HASH of target file calculated using choosen algorithm
	on fail, - ""
--------
Crypt.Hash.StrHash(string,HashAlg = 1,pwd = "",hmac_alg = 1)
	Gets the HASH of string. HASH will be calculated for ANSI representation of passed string
Parameters:
	string - UTF string
	other parameters same as for FileHash
=====================================================================
FileEncryptToStr(pFileIn,password,CryptAlg = 1, HashAlg = 1)
--------
	Encrypt file and returns it's hash
Parameters:
	pFileIn - path to file which will be encrypted
	password - no way, it's just a password...
	(optional) CryptAlg - Encryption algorithm ID, for details see below
	(optional) HashAlg - hashing algorithm ID, for details see below
Return:
	on success, - HASH of target file calculated using choosen algorithm
	on fail, - ""
=====================================================================
StrDecryptToFile(EncryptedHash,pFileOut,password,CryptAlg = 1, HashAlg = 1)
	Decrypt EncryptedHash to file and returns amount of bytes writen to file
Parameters:
	EncryptedHash - hash of formerly encrypted data
	pFileOut - path to destination file where decrypted data will be writen
	password - no way, it's just a password...
	(optional) CryptAlg - Encryption algorithm ID, for details see below
	(optional) HashAlg - hashing algorithm ID, for details see below
Return:
	on success, - amount of bytes writen to the destination file
	on fail, - ""
=====================================================================
Crypt.Encrypt class contain following fields
Crypt.Encrypt.StrEncoding - encoding of string passed to Crypt.Encrypt.StrEncrypt()
Crypt.Encrypt.PassEncoding - password encoding for each of Crypt.Encrypt methods

Same is valid for Crypt.Hash class

HASH and Encryption algorithms currently available:
HashAlg IDs:
1 - MD5
2 - MD2
3 - SHA
4 - SHA_256	;Vista+ only
5 - SHA_384	;Vista+ only
6 - SHA_512	;Vista+ only
--------
CryptAlg and hmac_alg IDs:
1 - RC4
2 - RC2
3 - 3DES
4 - 3DES_112
5 - AES_128 ;not supported for win 2000
6 - AES_192 ;not supported for win 2000
7 - AES_256 ;not supported for win 2000
=====================================================================

*/

class Crypt
{
	class Encrypt
	{
		static StrEncoding := "UTF-16"
		static PassEncoding := "UTF-16"
/*	
		StrDecryptToFile(EncryptedHash,pFileOut,password,CryptAlg = 1, HashAlg = 1) 
		{
			if !EncryptedHash
				return ""
			if !len := b64Decode( EncryptedHash, encr_Buf )
				return ""
			temp_file := "crypt.temp"
			f := FileOpen(temp_file,"w","CP0")
			if !IsObject(f)
				return ""
			if !f.RawWrite(encr_Buf,len)
				return ""
			f.close()
			bytes := this._Encrypt( p, pp, password, 0, temp_file, pFileOut, CryptAlg, HashAlg )
			FileDelete,% temp_file
			return bytes
		}
		
		FileEncryptToStr(pFileIn,password,CryptAlg = 1, HashAlg = 1) 
		{
			temp_file := "crypt.temp"
			if !this._Encrypt( p, pp, password, 1, pFileIn, temp_file, CryptAlg, HashAlg )
				return ""
			f := FileOpen(temp_file,"r","CP0")
			if !IsObject(f)
			{
				FileDelete,% temp_file
				return ""
			}
			f.Pos := 0
			fLen := f.Length
			VarSetCapacity(tembBuf,fLen,0)
			if !f.RawRead(tembBuf,fLen)
			{
				Free(tembBuf)
				return ""
			}
			f.Close()
			FileDelete,% temp_file
			return b64Encode( tembBuf, fLen )
		}
		
		FileEncrypt(pFileIn,pFileOut,password,CryptAlg = 1, HashAlg = 1)
		{
			return this._Encrypt( p, pp, password, 1, pFileIn, pFileOut, CryptAlg, HashAlg )
		}

		FileDecrypt(pFileIn,pFileOut,password,CryptAlg = 1, HashAlg = 1)
		{
			return this._Encrypt( p, pp, password, 0, pFileIn, pFileOut, CryptAlg, HashAlg )
		}
*/
		StrEncrypt(string,password,CryptAlg = 1, HashAlg = 1)
		{
			len := StrPutVar(string, str_buf,100,this.StrEncoding)
			if this._Encrypt(str_buf,len, password, 1,0,0,CryptAlg,HashAlg)
				return b64Encode( str_buf, len )
			else
				return ""
		}
	
		StrDecrypt(EncryptedHash,password,CryptAlg = 1, HashAlg = 1)
		{
			if !EncryptedHash
				return ""
			if !len := b64Decode( EncryptedHash, encr_Buf )
				return 0
			if sLen := this._Encrypt(encr_Buf,len, password, 0,0,0,CryptAlg,HashAlg)
			{
				if ( this.StrEncoding = "utf-16" || this.StrEncoding = "cp1200" )
					sLen /= 2
				return strget(&encr_Buf,sLen,this.StrEncoding)
			}
			else
				return ""
		}		
	
		_Encrypt(ByRef encr_Buf,ByRef Buf_Len, password, mode, pFileIn=0, pFileOut=0, CryptAlg = 1,HashAlg = 1)	;mode - 1 encrypt, 0 - decrypt
		{
			c := CryptConst
			;password hashing algorithms
			CUR_PWD_HASH_ALG := HashAlg == 1 || HashAlg = "MD5" ?c.CALG_MD5
												:HashAlg==2 || HashAlg = "MD2" 	?c.CALG_MD2
												:HashAlg==3 || HashAlg = "SHA"	?c.CALG_SHA
												:HashAlg==4 || HashAlg = "SHA256" ?c.CALG_SHA_256	;Vista+ only
												:HashAlg==5 || HashAlg = "SHA384" ?c.CALG_SHA_384	;Vista+ only
												:HashAlg==6 || HashAlg = "SHA512" ?c.CALG_SHA_512	;Vista+ only
												:0
			;encryption algorithms
			CUR_ENC_ALG 	:= CryptAlg==1 || CryptAlg = "RC4" 			? ( c.CALG_RC4, KEY_LENGHT:=0x80 )
											:CryptAlg==2 || CryptAlg = "RC2" 		? ( c.CALG_RC2, KEY_LENGHT:=0x80 )
											:CryptAlg==3 || CryptAlg = "3DES" 		? ( c.CALG_3DES, KEY_LENGHT:=0xC0 )
											:CryptAlg==4 || CryptAlg = "3DES112" ? ( c.CALG_3DES_112, KEY_LENGHT:=0x80 )
											:CryptAlg==5 || CryptAlg = "AES128" 	? ( c.CALG_AES_128, KEY_LENGHT:=0x80 ) ;not supported for win 2000
											:CryptAlg==6 || CryptAlg = "AES192" 	? ( c.CALG_AES_192, KEY_LENGHT:=0xC0 )	;not supported for win 2000
											:CryptAlg==7 || CryptAlg = "AES256" 	? ( c.CALG_AES_256, KEY_LENGHT:=0x100 )	;not supported for win 2000
											:0
			KEY_LENGHT <<= 16
			if (CUR_PWD_HASH_ALG = 0 || CUR_ENC_ALG = 0)
				return 0
			
			if !dllCall("Advapi32\CryptAcquireContextW","Ptr*",hCryptProv,"Uint",0,"Uint",0,"Uint",c.PROV_RSA_AES,"UInt",c.CRYPT_VERIFYCONTEXT)
					{foo := "CryptAcquireContextW", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_LA_COMEDIA
					}	
			if !dllCall("Advapi32\CryptCreateHash","Ptr",hCryptProv,"Uint",CUR_PWD_HASH_ALG,"Uint",0,"Uint",0,"Ptr*",hHash )
					{foo := "CryptCreateHash", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_LA_COMEDIA
					}
			;hashing password
			passLen := StrPutVar(password, passBuf,0,this.PassEncoding)
			if !dllCall("Advapi32\CryptHashData","Ptr",hHash,"Ptr",&passBuf,"Uint",passLen,"Uint",0 )
					{foo := "CryptHashData", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_LA_COMEDIA
					}	
			;getting encryption key from password
			if !dllCall("Advapi32\CryptDeriveKey","Ptr",hCryptProv,"Uint",CUR_ENC_ALG,"Ptr",hHash,"Uint",KEY_LENGHT,"Ptr*",hKey )
					{foo := "CryptDeriveKey", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_LA_COMEDIA
					}
			;~ SetKeySalt(hKey,hCryptProv)
			if !dllCall("Advapi32\CryptGetKeyParam","Ptr",hKey,"Uint",c.KP_BLOCKLEN,"Uint*",BlockLen,"Uint*",dwCount := 4,"Uint",0)
					{foo := "CryptGetKeyParam", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_LA_COMEDIA
					}	
			BlockLen /= 8
			if (mode == 1)							;Encrypting
			{
				if (pFileIn && pFileOut)			;encrypting file
				{
					ReadBufSize := 10240 - mod(10240,BlockLen==0?1:BlockLen )	;10KB
					pfin := FileOpen(pFileIn,"r","CP0")
					pfout := FileOpen(pFileOut,"w","CP0")
					if !IsObject(pfin)
						{foo := "File Opening " . pFileIn
						GoTO FINITA_LA_COMEDIA
						}
					if !IsObject(pfout)
						{foo := "File Opening " . pFileOut
						GoTO FINITA_LA_COMEDIA
						}
					pfin.Pos := 0
					VarSetCapacity(ReadBuf,ReadBufSize+BlockLen,0)
					isFinal := 0
					hModule := DllCall("LoadLibrary", "Str", "Advapi32.dll","UPtr")
					CryptEnc := DllCall("GetProcAddress", "Ptr", hModule, "AStr", "CryptEncrypt","UPtr")
					while !pfin.AtEOF
					{
						BytesRead := pfin.RawRead(ReadBuf, ReadBufSize)
						if pfin.AtEOF
							isFinal := 1
						if !dllCall(CryptEnc
								,"Ptr",hKey	;key
								,"Ptr",0	;hash
								,"Uint",isFinal	;final
								,"Uint",0	;dwFlags
								,"Ptr",&ReadBuf	;pbdata
								,"Uint*",BytesRead	;dwsize
								,"Uint",ReadBufSize+BlockLen )	;dwbuf		
						{foo := "CryptEncrypt", err := GetLastError(), err2 := ErrorLevel
						GoTO FINITA_LA_COMEDIA
						}	
						pfout.RawWrite(ReadBuf,BytesRead)
						Buf_Len += BytesRead
					}
					DllCall("FreeLibrary", "Ptr", hModule)
					pfin.Close()
					pfout.Close()
				}
				else
				{
					if !dllCall("Advapi32\CryptEncrypt"
								,"Ptr",hKey	;key
								,"Ptr",0	;hash
								,"Uint",1	;final
								,"Uint",0	;dwFlags
								,"Ptr",&encr_Buf	;pbdata
								,"Uint*",Buf_Len	;dwsize
								,"Uint",Buf_Len + BlockLen )	;dwbuf		
					{foo := "CryptEncrypt", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_LA_COMEDIA
					}	
				}
			}
			else if (mode == 0)								;decrypting
			{	
				if (pFileIn && pFileOut)					;decrypting file
				{
					ReadBufSize := 10240 - mod(10240,BlockLen==0?1:BlockLen )	;10KB
					pfin := FileOpen(pFileIn,"r","CP0")
					pfout := FileOpen(pFileOut,"w","CP0")
					if !IsObject(pfin)
						{foo := "File Opening " . pFileIn
						GoTO FINITA_LA_COMEDIA
						}
					if !IsObject(pfout)
						{foo := "File Opening " . pFileOut
						GoTO FINITA_LA_COMEDIA
						}
					pfin.Pos := 0
					VarSetCapacity(ReadBuf,ReadBufSize+BlockLen,0)
					isFinal := 0
					hModule := DllCall("LoadLibrary", "Str", "Advapi32.dll","UPtr")
					CryptDec := DllCall("GetProcAddress", "Ptr", hModule, "AStr", "CryptDecrypt","UPtr")
					while !pfin.AtEOF
					{
						BytesRead := pfin.RawRead(ReadBuf, ReadBufSize)
						if pfin.AtEOF
							isFinal := 1
						if !dllCall(CryptDec
								,"Ptr",hKey	;key
								,"Ptr",0	;hash
								,"Uint",isFinal	;final
								,"Uint",0	;dwFlags
								,"Ptr",&ReadBuf	;pbdata
								,"Uint*",BytesRead )	;dwsize
						{foo := "CryptDecrypt", err := GetLastError(), err2 := ErrorLevel
						GoTO FINITA_LA_COMEDIA
						}	
						pfout.RawWrite(ReadBuf,BytesRead)
						Buf_Len += BytesRead
					}
					DllCall("FreeLibrary", "Ptr", hModule)
					pfin.Close()
					pfout.Close()
					
				}
				else if !dllCall("Advapi32\CryptDecrypt"
								,"Ptr",hKey	;key
								,"Ptr",0	;hash
								,"Uint",1	;final
								,"Uint",0	;dwFlags
								,"Ptr",&encr_Buf	;pbdata
								,"Uint*",Buf_Len )	;dwsize
					{foo := "CryptDecrypt", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_LA_COMEDIA
					}	
			}
FINITA_LA_COMEDIA:
			dllCall("Advapi32\CryptDestroyKey","Ptr",hKey )
			dllCall("Advapi32\CryptDestroyHash","Ptr",hHash)
			dllCall("Advapi32\CryptReleaseContext","Ptr",hCryptProv,"UInt",0)
			if (A_ThisLabel = "FINITA_LA_COMEDIA")
			{
				if (A_IsCompiled = 1)
					return ""
				else
					msgbox % foo " call failed with:`nErrorLevel: " err2 "`nLastError: " err "`n" ErrorFormat(err) 
				return ""
			}
			return Buf_Len
		}
	}
	
	class Hash
	{
		static StrEncoding := "CP0"
		static PassEncoding := "UTF-16"
		
		FileHash(pFile,HashAlg = 1,pwd = "",hmac_alg = 1)
		{
			return this._CalcHash(p,pp,pFile,HashAlg,pwd,hmac_alg)
		}
		
		StrHash(string,HashAlg = 1,pwd = "",hmac_alg = 1)		;strType 1 for ASC, 0 for UTF
		{
			buf_len := StrPutVar(string, buf,0,this.StrEncoding)
			return this._CalcHash(buf,buf_len,0,HashAlg,pwd,hmac_alg)
		}
		
		_CalcHash(ByRef bBuffer,BufferLen,pFile,HashAlg = 1,pwd = "",hmac_alg = 1)
		{
			c := CryptConst
			;password hashing algorithms
			HASH_ALG := HashAlg==1?c.CALG_MD5
						:HashAlg==2?c.CALG_MD2
						:HashAlg==3?c.CALG_SHA
						:HashAlg==4?c.CALG_SHA_256	;Vista+ only
						:HashAlg==5?c.CALG_SHA_384	;Vista+ only
						:HashAlg==6?c.CALG_SHA_512	;Vista+ only
						:0
			;encryption algorithms
			HMAC_KEY_ALG 	:= hmac_alg==1?c.CALG_RC4
								:hmac_alg==2?c.CALG_RC2
								:hmac_alg==3?c.CALG_3DES
								:hmac_alg==4?c.CALG_3DES_112
								:hmac_alg==5?c.CALG_AES_128 ;not supported for win 2000
								:hmac_alg==6?c.CALG_AES_192	;not supported for win 2000
								:hmac_alg==7?c.CALG_AES_256	;not supported for win 2000
								:0
			KEY_LENGHT 		:= hmac_alg==1?0x80
								:hmac_alg==2?0x80
								:hmac_alg==3?0xC0
								:hmac_alg==4?0x80
								:hmac_alg==5?0x80
								:hmac_alg==6?0xC0
								:hmac_alg==7?0x100
								:0
			KEY_LENGHT <<= 16
			if (!HASH_ALG || !HMAC_KEY_ALG)
				return 0
			if !dllCall("Advapi32\CryptAcquireContextW","Ptr*",hCryptProv,"Uint",0,"Uint",0,"Uint",c.PROV_RSA_AES,"UInt",c.CRYPT_VERIFYCONTEXT )
				{foo := "CryptAcquireContextW", err := GetLastError(), err2 := ErrorLevel
				GoTO FINITA_DA_COMEDIA
				}	
			if !dllCall("Advapi32\CryptCreateHash","Ptr",hCryptProv,"Uint",HASH_ALG,"Uint",0,"Uint",0,"Ptr*",hHash )
				{foo := "CryptCreateHash1", err := GetLastError(), err2 := ErrorLevel
				GoTO FINITA_DA_COMEDIA
				}
			
			if (pwd != "")			;going HMAC
			{
				passLen := StrPutVar(pwd, passBuf,0,this.PassEncoding)
				if !dllCall("Advapi32\CryptHashData","Ptr",hHash,"Ptr",&passBuf,"Uint",passLen,"Uint",0 )
					{foo := "CryptHashData Pwd", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_DA_COMEDIA
					}
				;getting encryption key from password
				if !dllCall("Advapi32\CryptDeriveKey","Ptr",hCryptProv,"Uint",HMAC_KEY_ALG,"Ptr",hHash,"Uint",KEY_LENGHT,"Ptr*",hKey )
					{foo := "CryptDeriveKey Pwd", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_DA_COMEDIA
					}
				dllCall("Advapi32\CryptDestroyHash","Ptr",hHash)
				if !dllCall("Advapi32\CryptCreateHash","Ptr",hCryptProv,"Uint",c.CALG_HMAC,"Ptr",hKey,"Uint",0,"Ptr*",hHash )
					{foo := "CryptCreateHash2", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_DA_COMEDIA
					}
				VarSetCapacity(HmacInfoStruct,4*A_PtrSize + 4,0)
				NumPut(HASH_ALG,HmacInfoStruct,0,"UInt")
				if !dllCall("Advapi32\CryptSetHashParam","Ptr",hHash,"Uint",c.HP_HMAC_INFO,"Ptr",&HmacInfoStruct,"Uint",0)
					{foo := "CryptSetHashParam", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_DA_COMEDIA
					}
			}
				
			if pFile
			{
				f := FileOpen(pFile,"r","CP0")
				BUFF_SIZE := 1024 * 1024 ; 1 MB
				if !IsObject(f)
					{foo := "File Opening"
					GoTO FINITA_DA_COMEDIA
					}
				if !hModule := DllCall( "GetModuleHandleW", "str", "Advapi32.dll", "UPtr" )
					hModule := DllCall( "LoadLibraryW", "str", "Advapi32.dll", "UPtr" )
				hCryptHashData := DllCall("GetProcAddress", "Ptr", hModule, "AStr", "CryptHashData", "UPtr")
				VarSetCapacity(read_buf,BUFF_SIZE,0)
				f.Pos := 0
				While (cbCount := f.RawRead(read_buf, BUFF_SIZE))
				{
					if (cbCount = 0)
						break
					if !dllCall(hCryptHashData
								,"Ptr",hHash
								,"Ptr",&read_buf
								,"Uint",cbCount
								,"Uint",0 )
						{foo := "CryptHashData", err := GetLastError(), err2 := ErrorLevel
						GoTO FINITA_DA_COMEDIA
						}
				}
				f.Close()
			}
			else
			{
				if !dllCall("Advapi32\CryptHashData"
							,"Ptr",hHash
							,"Ptr",&bBuffer
							,"Uint",BufferLen
							,"Uint",0 )
					{foo := "CryptHashData", err := GetLastError(), err2 := ErrorLevel
					GoTO FINITA_DA_COMEDIA
					}
			}
			if !dllCall("Advapi32\CryptGetHashParam","Ptr",hHash,"Uint",c.HP_HASHSIZE,"Uint*",HashLen,"Uint*",HashLenSize := 4,"UInt",0 )
				{foo := "CryptGetHashParam HP_HASHSIZE", err := GetLastError(), err2 := ErrorLevel
				GoTO FINITA_DA_COMEDIA
				}
			VarSetCapacity(pbHash,HashLen,0)
			if !dllCall("Advapi32\CryptGetHashParam","Ptr",hHash,"Uint",c.HP_HASHVAL,"Ptr",&pbHash,"Uint*",HashLen,"UInt",0 )
				{foo := "CryptGetHashParam HP_HASHVAL", err := GetLastError(), err2 := ErrorLevel
				GoTO FINITA_DA_COMEDIA
				}
			hashval := b2a_hex( pbHash, HashLen )
				
		FINITA_DA_COMEDIA:
			DllCall("FreeLibrary", "Ptr", hModule)
			dllCall("Advapi32\CryptDestroyHash","Ptr",hHash)
			dllCall("Advapi32\CryptDestroyKey","Ptr",hKey )
			dllCall("Advapi32\CryptReleaseContext","Ptr",hCryptProv,"UInt",0)
			if (A_ThisLabel = "FINITA_LA_COMEDIA")
			{
				if (A_IsCompiled = 1)
					return ""
				else
					msgbox % foo " call failed with:`nErrorLevel: " err2 "`nLastError: " err "`n" ErrorFormat(err) 
				return 0
			}
			return hashval
		}
	}
}

;returns positive hex value of last error
GetLastError()
{
	return ToHex(A_LastError < 0 ? A_LastError & 0xFFFFFFFF : A_LastError)
}

;converting decimal to hex value
ToHex(num)
{
	if num is not integer
		return num
	oldFmt := A_FormatInteger
	SetFormat, integer, hex
	num := num + 0
	SetFormat, integer,% oldFmt
	return num
}

;And this function returns error description based on error number passed. ;
;Error number is one returned by GetLastError() or from A_LastError
ErrorFormat(error_id)
{
	VarSetCapacity(msg,1000,0)
	if !len := DllCall("FormatMessageW"
				,"UInt",FORMAT_MESSAGE_FROM_SYSTEM := 0x00001000 | FORMAT_MESSAGE_IGNORE_INSERTS := 0x00000200		;dwflags
				,"Ptr",0		;lpSource
				,"UInt",error_id	;dwMessageId
				,"UInt",0			;dwLanguageId
				,"Ptr",&msg			;lpBuffer
				,"UInt",500)			;nSize
		return
	return 	strget(&msg,len)
}

StrPutVar(string, ByRef var, addBufLen = 0,encoding="UTF-16")
{
	; Ensure capacity.
	; StrPut returns char count, but VarSetCapacity needs bytes.
	tlen := ((encoding="utf-16"||encoding="cp1200") ? 2 : 1)
	str_len := StrPut(string, encoding) * tlen
    VarSetCapacity( var, str_len + addBufLen,0 )
    ; Copy or convert the string.
	StrPut( string, &var, encoding )
    return str_len - tlen
}

/*
SetKeySalt(hKey,hProv)
{
	KP_SALT_EX := 10
	SALT := "89ABF9C1005EDD40"
	;~ len := HashToByte(SALT,pb)
	VarSetCapacity(st,2*A_PtrSize,0)
	NumPut(len,st,0,"UInt")
	NumPut(&pb,st,A_PtrSize,"UPtr")
	if !dllCall("Advapi32\CryptSetKeyParam"
				,"Ptr",hKey
				,"Uint",KP_SALT_EX
				,"Ptr",&st
				,"Uint",0)
		msgbox % ErrorFormat(GetLastError())
}

GetKeySalt(hKey)
{
	KP_IV := 1       ; Initialization vector
	KP_SALT := 2       ; Salt value
	if !dllCall("Advapi32\CryptGetKeyParam"
				,"Ptr",hKey
				,"Uint",KP_SALT
				,"Uint",0
				,"Uint*",dwCount
				,"Uint",0)
	msgbox % "Fail to get SALT length."
	msgbox % "SALT length.`n" dwCount
	VarSetCapacity(pb,dwCount,0)
	if !dllCall("Advapi32\CryptGetKeyParam"
				,"Ptr",hKey
				,"Uint",KP_SALT
				,"Ptr",&pb
				,"Uint*",dwCount
				,"Uint",0)
	msgbox % "Fail to get SALT"	
	;~ msgbox % ByteToHash(pb,dwCount) "`n" dwCount
}
*/

class CryptConst
{
static ALG_CLASS_ANY := (0)
static ALG_CLASS_SIGNATURE := (1 << 13)
static ALG_CLASS_MSG_ENCRYPT := (2 << 13)
static ALG_CLASS_DATA_ENCRYPT := (3 << 13)
static ALG_CLASS_HASH := (4 << 13)
static ALG_CLASS_KEY_EXCHANGE := (5 << 13)
static ALG_CLASS_ALL := (7 << 13)
static ALG_TYPE_ANY := (0)
static ALG_TYPE_DSS := (1 << 9)
static ALG_TYPE_RSA := (2 << 9)
static ALG_TYPE_BLOCK := (3 << 9)
static ALG_TYPE_STREAM := (4 << 9)
static ALG_TYPE_DH := (5 << 9)
static ALG_TYPE_SECURECHANNEL := (6 << 9)
static ALG_SID_ANY := (0)
static ALG_SID_RSA_ANY := 0
static ALG_SID_RSA_PKCS := 1
static ALG_SID_RSA_MSATWORK := 2
static ALG_SID_RSA_ENTRUST := 3
static ALG_SID_RSA_PGP := 4
static ALG_SID_DSS_ANY := 0
static ALG_SID_DSS_PKCS := 1
static ALG_SID_DSS_DMS := 2
static ALG_SID_ECDSA := 3
static ALG_SID_DES := 1
static ALG_SID_3DES := 3
static ALG_SID_DESX := 4
static ALG_SID_IDEA := 5
static ALG_SID_CAST := 6
static ALG_SID_SAFERSK64 := 7
static ALG_SID_SAFERSK128 := 8
static ALG_SID_3DES_112 := 9
static ALG_SID_CYLINK_MEK := 12
static ALG_SID_RC5 := 13
static ALG_SID_AES_128 := 14
static ALG_SID_AES_192 := 15
static ALG_SID_AES_256 := 16
static ALG_SID_AES := 17
static ALG_SID_SKIPJACK := 10
static ALG_SID_TEK := 11
static CRYPT_MODE_CBCI := 6       ; ANSI CBC Interleaved
static CRYPT_MODE_CFBP := 7       ; ANSI CFB Pipelined
static CRYPT_MODE_OFBP := 8       ; ANSI OFB Pipelined
static CRYPT_MODE_CBCOFM := 9       ; ANSI CBC + OF Masking
static CRYPT_MODE_CBCOFMI := 10      ; ANSI CBC + OFM Interleaved
static ALG_SID_RC2 := 2
static ALG_SID_RC4 := 1
static ALG_SID_SEAL := 2
static ALG_SID_DH_SANDF := 1
static ALG_SID_DH_EPHEM := 2
static ALG_SID_AGREED_KEY_ANY := 3
static ALG_SID_KEA := 4
static ALG_SID_ECDH := 5
static ALG_SID_MD2 := 1
static ALG_SID_MD4 := 2
static ALG_SID_MD5 := 3
static ALG_SID_SHA := 4
static ALG_SID_SHA1 := 4
static ALG_SID_MAC := 5
static ALG_SID_RIPEMD := 6
static ALG_SID_RIPEMD160 := 7
static ALG_SID_SSL3SHAMD5 := 8
static ALG_SID_HMAC := 9
static ALG_SID_TLS1PRF := 10
static ALG_SID_HASH_REPLACE_OWF := 11
static ALG_SID_SHA_256 := 12
static ALG_SID_SHA_384 := 13
static ALG_SID_SHA_512 := 14
static ALG_SID_SSL3_MASTER := 1
static ALG_SID_SCHANNEL_MASTER_HASH := 2
static ALG_SID_SCHANNEL_MAC_KEY := 3
static ALG_SID_PCT1_MASTER := 4
static ALG_SID_SSL2_MASTER := 5
static ALG_SID_TLS1_MASTER := 6
static ALG_SID_SCHANNEL_ENC_KEY := 7
static ALG_SID_ECMQV := 1
static ALG_SID_EXAMPLE := 80
static CALG_MD2 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_MD2)
static CALG_MD4 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_MD4)
static CALG_MD5 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_MD5)
static CALG_SHA := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_SHA)
static CALG_SHA1 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_SHA1)
static CALG_MAC := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_MAC)
static CALG_RSA_SIGN := (CryptConst.ALG_CLASS_SIGNATURE | CryptConst.ALG_TYPE_RSA | CryptConst.ALG_SID_RSA_ANY)
static CALG_DSS_SIGN := (CryptConst.ALG_CLASS_SIGNATURE | CryptConst.ALG_TYPE_DSS | CryptConst.ALG_SID_DSS_ANY)
static CALG_NO_SIGN := (CryptConst.ALG_CLASS_SIGNATURE | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_ANY)
static CALG_RSA_KEYX := (CryptConst.ALG_CLASS_KEY_EXCHANGE|CryptConst.ALG_TYPE_RSA|CryptConst.ALG_SID_RSA_ANY)
static CALG_DES := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_DES)
static CALG_3DES_112 := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_3DES_112)
static CALG_3DES := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_3DES)
static CALG_DESX := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_DESX)
static CALG_RC2 := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_RC2)
static CALG_RC4 := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_STREAM|CryptConst.ALG_SID_RC4)
static CALG_SEAL := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_STREAM|CryptConst.ALG_SID_SEA)
static CALG_DH_SF := (CryptConst.ALG_CLASS_KEY_EXCHANGE|CryptConst.ALG_TYPE_DH|CryptConst.ALG_SID_DH_SANDF)
static CALG_DH_EPHEM := (CryptConst.ALG_CLASS_KEY_EXCHANGE|CryptConst.ALG_TYPE_DH|CryptConst.ALG_SID_DH_EPHEM)
static CALG_AGREEDKEY_ANY := (CryptConst.ALG_CLASS_KEY_EXCHANGE|CryptConst.ALG_TYPE_DH|CryptConst.ALG_SID_AGREED_KEY_ANY)
static CALG_KEA_KEYX := (CryptConst.ALG_CLASS_KEY_EXCHANGE|CryptConst.ALG_TYPE_DH|CryptConst.ALG_SID_KEA)
static CALG_HUGHES_MD5 := (CryptConst.ALG_CLASS_KEY_EXCHANGE|CryptConst.ALG_TYPE_ANY|CryptConst.ALG_SID_MD5)
static CALG_SKIPJACK := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_SKIPJACK)
static CALG_TEK := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_TEK)
static CALG_CYLINK_MEK := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_CYLINK_MEK)
static CALG_SSL3_SHAMD5 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_SSL3SHAMD5)
static CALG_SSL3_MASTER := (CryptConst.ALG_CLASS_MSG_ENCRYPT|CryptConst.ALG_TYPE_SECURECHANNEL|CryptConst.ALG_SID_SSL3_MASTER)
static CALG_SCHANNEL_MASTER_HASH := (CryptConst.ALG_CLASS_MSG_ENCRYPT|CryptConst.ALG_TYPE_SECURECHANNEL|CryptConst.ALG_SID_SCHANNEL_MASTER_HASH)
static CALG_SCHANNEL_MAC_KEY := (CryptConst.ALG_CLASS_MSG_ENCRYPT|CryptConst.ALG_TYPE_SECURECHANNEL|CryptConst.ALG_SID_SCHANNEL_MAC_KEY)
static CALG_SCHANNEL_ENC_KEY := (CryptConst.ALG_CLASS_MSG_ENCRYPT|CryptConst.ALG_TYPE_SECURECHANNEL|CryptConst.ALG_SID_SCHANNEL_ENC_KEY)
static CALG_PCT1_MASTER := (CryptConst.ALG_CLASS_MSG_ENCRYPT|CryptConst.ALG_TYPE_SECURECHANNEL|CryptConst.ALG_SID_PCT1_MASTER)
static CALG_SSL2_MASTER := (CryptConst.ALG_CLASS_MSG_ENCRYPT|CryptConst.ALG_TYPE_SECURECHANNEL|CryptConst.ALG_SID_SSL2_MASTER)
static CALG_TLS1_MASTER := (CryptConst.ALG_CLASS_MSG_ENCRYPT|CryptConst.ALG_TYPE_SECURECHANNEL|CryptConst.ALG_SID_TLS1_MASTER)
static CALG_RC5 := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_RC5)
static CALG_HMAC := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_HMAC)
static CALG_TLS1PRF := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_TLS1PRF)
static CALG_HASH_REPLACE_OWF := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_HASH_REPLACE_OWF)
static CALG_AES_128 := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_AES_128)
static CALG_AES_192 := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_AES_192)
static CALG_AES_256 := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_AES_256)
static CALG_AES := (CryptConst.ALG_CLASS_DATA_ENCRYPT|CryptConst.ALG_TYPE_BLOCK|CryptConst.ALG_SID_AES)
static CALG_SHA_256 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_SHA_256)
static CALG_SHA_384 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_SHA_384)
static CALG_SHA_512 := (CryptConst.ALG_CLASS_HASH | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_SHA_512)
static CALG_ECDH := (CryptConst.ALG_CLASS_KEY_EXCHANGE | CryptConst.ALG_TYPE_DH | CryptConst.ALG_SID_ECDH)
static CALG_ECMQV := (CryptConst.ALG_CLASS_KEY_EXCHANGE | CryptConst.ALG_TYPE_ANY | CryptConst.ALG_SID_ECMQV)
static CALG_ECDSA := (CryptConst.ALG_CLASS_SIGNATURE | CryptConst.ALG_TYPE_DSS | CryptConst.ALG_SID_ECDSA)
static CRYPT_VERIFYCONTEXT := 0xF0000000
static CRYPT_NEWKEYSET := 0x00000008
static CRYPT_DELETEKEYSET := 0x00000010
static CRYPT_MACHINE_KEYSET := 0x00000020
static CRYPT_SILENT := 0x00000040
static CRYPT_DEFAULT_CONTAINER_OPTIONAL := 0x00000080
static CRYPT_EXPORTABLE := 0x00000001
static CRYPT_USER_PROTECTED := 0x00000002
static CRYPT_CREATE_SALT := 0x00000004
static CRYPT_UPDATE_KEY := 0x00000008
static CRYPT_NO_SALT := 0x00000010
static CRYPT_PREGEN := 0x00000040
static CRYPT_RECIPIENT := 0x00000010
static CRYPT_INITIATOR := 0x00000040
static CRYPT_ONLINE := 0x00000080
static CRYPT_SF := 0x00000100
static CRYPT_CREATE_IV := 0x00000200
static CRYPT_KEK := 0x00000400
static CRYPT_DATA_KEY := 0x00000800
static CRYPT_VOLATILE := 0x00001000
static CRYPT_SGCKEY := 0x00002000
static CRYPT_ARCHIVABLE := 0x00004000
static CRYPT_FORCE_KEY_PROTECTION_HIGH := 0x00008000
static RSA1024BIT_KEY := 0x04000000
static CRYPT_SERVER := 0x00000400
static KEY_LENGTH_MASK := 0xFFFF0000
static CRYPT_Y_ONLY := 0x00000001
static CRYPT_SSL2_FALLBACK := 0x00000002
static CRYPT_DESTROYKEY := 0x00000004
static CRYPT_OAEP := 0x00000040  ; used with RSA encryptions/decryptions
static CRYPT_BLOB_VER3 := 0x00000080  ; export version 3 of a blob type
static CRYPT_IPSEC_HMAC_KEY := 0x00000100  ; CryptImportKey only
static CRYPT_DECRYPT_RSA_NO_PADDING_CHECK := 0x00000020
static CRYPT_SECRETDIGEST := 0x00000001
static CRYPT_OWF_REPL_LM_HASH := 0x00000001  ; this is only for the OWF replacement CSP
static CRYPT_LITTLE_ENDIAN := 0x00000001
static CRYPT_NOHASHOID := 0x00000001
static CRYPT_TYPE2_FORMAT := 0x00000002
static CRYPT_X931_FORMAT := 0x00000004
static CRYPT_MACHINE_DEFAULT := 0x00000001
static CRYPT_USER_DEFAULT := 0x00000002
static CRYPT_DELETE_DEFAULT := 0x00000004
static SIMPLEBLOB := 0x1
static PUBLICKEYBLOB := 0x6
static PRIVATEKEYBLOB := 0x7
static PLAINTEXTKEYBLOB := 0x8
static OPAQUEKEYBLOB := 0x9
static PUBLICKEYBLOBEX := 0xA
static SYMMETRICWRAPKEYBLOB := 0xB
static KEYSTATEBLOB := 0xC
static AT_KEYEXCHANGE := 1
static AT_SIGNATURE := 2
static CRYPT_USERDATA := 1
static KP_IV := 1       ; Initialization vector
static KP_SALT := 2       ; Salt value
static KP_PADDING := 3       ; Padding values
static KP_MODE := 4       ; Mode of the cipher
static KP_MODE_BITS := 5       ; Number of bits to feedback
static KP_PERMISSIONS := 6       ; Key permissions DWORD
static KP_ALGID := 7       ; Key algorithm
static KP_BLOCKLEN := 8       ; Block size of the cipher
static KP_KEYLEN := 9       ; Length of key in bits
static KP_SALT_EX := 10      ; Length of salt in bytes
static KP_P := 11      ; DSS/Diffie-Hellman P value
static KP_G := 12      ; DSS/Diffie-Hellman G value
static KP_Q := 13      ; DSS Q value
static KP_X := 14      ; Diffie-Hellman X value
static KP_Y := 15      ; Y value
static KP_RA := 16      ; Fortezza RA value
static KP_RB := 17      ; Fortezza RB value
static KP_INFO := 18      ; for putting information into an RSA envelope
static KP_EFFECTIVE_KEYLEN := 19      ; setting and getting RC2 effective key length
static KP_SCHANNEL_ALG := 20      ; for setting the Secure Channel algorithms
static KP_CLIENT_RANDOM := 21      ; for setting the Secure Channel client random data
static KP_SERVER_RANDOM := 22      ; for setting the Secure Channel server random data
static KP_RP := 23
static KP_PRECOMP_MD5 := 24
static KP_PRECOMP_SHA := 25
static KP_CERTIFICATE := 26      ; for setting Secure Channel certificate data (PCT1)
static KP_CLEAR_KEY := 27      ; for setting Secure Channel clear key data (PCT1)
static KP_PUB_EX_LEN := 28
static KP_PUB_EX_VAL := 29
static KP_KEYVAL := 30
static KP_ADMIN_PIN := 31
static KP_KEYEXCHANGE_PIN := 32
static KP_SIGNATURE_PIN := 33
static KP_PREHASH := 34
static KP_ROUNDS := 35
static KP_OAEP_PARAMS := 36      ; for setting OAEP params on RSA keys
static KP_CMS_KEY_INFO := 37
static KP_CMS_DH_KEY_INFO := 38
static KP_PUB_PARAMS := 39      ; for setting public parameters
static KP_VERIFY_PARAMS := 40      ; for verifying DSA and DH parameters
static KP_HIGHEST_VERSION := 41      ; for TLS protocol version setting
static KP_GET_USE_COUNT := 42      ; for use with PP_CRYPT_COUNT_KEY_USE contexts
static KP_PIN_ID := 43
static KP_PIN_INFO := 44
static HP_ALGID := 0x0001  ; Hash algorithm
static HP_HASHVAL := 0x0002  ; Hash value
static HP_HASHSIZE := 0x0004  ; Hash value size
static HP_HMAC_INFO := 0x0005  ; information for creating an HMAC
static HP_TLS1PRF_LABEL := 0x0006  ; label for TLS1 PRF
static HP_TLS1PRF_SEED := 0x0007  ; seed for TLS1 PRF
static PROV_RSA_FULL := 1
static PROV_RSA_SIG := 2
static PROV_DSS := 3
static PROV_FORTEZZA := 4
static PROV_MS_EXCHANGE := 5
static PROV_SSL := 6
static PROV_RSA_SCHANNEL := 12
static PROV_DSS_DH := 13
static PROV_EC_ECDSA_SIG := 14
static PROV_EC_ECNRA_SIG := 15
static PROV_EC_ECDSA_FULL := 16
static PROV_EC_ECNRA_FULL := 17
static PROV_DH_SCHANNEL := 18
static PROV_SPYRUS_LYNKS := 20
static PROV_RNG := 21
static PROV_INTEL_SEC := 22
static PROV_REPLACE_OWF := 23
static PROV_RSA_AES := 24
static PROV_STT_MER := 7
static PROV_STT_ACQ := 8
static PROV_STT_BRND := 9
static PROV_STT_ROOT := 10
static PROV_STT_ISS := 11
}


b64Encode( ByRef buf, bufLen )
{
	DllCall( "crypt32\CryptBinaryToStringA", "ptr", &buf, "UInt", bufLen, "Uint", 1 | 0x40000000, "Ptr", 0, "UInt*", outLen )
	VarSetCapacity( outBuf, outLen, 0 )
	DllCall( "crypt32\CryptBinaryToStringA", "ptr", &buf, "UInt", bufLen, "Uint", 1 | 0x40000000, "Ptr", &outBuf, "UInt*", outLen )
	return strget( &outBuf, outLen, "CP0" )
}


b64Decode( b64str, ByRef outBuf )
{
   static CryptStringToBinary := "crypt32\CryptStringToBinary" (A_IsUnicode ? "W" : "A")

   DllCall( CryptStringToBinary, "ptr", &b64str, "UInt", 0, "Uint", 1, "Ptr", 0, "UInt*", outLen, "ptr", 0, "ptr", 0 )
   VarSetCapacity( outBuf, outLen, 0 )
   DllCall( CryptStringToBinary, "ptr", &b64str, "UInt", 0, "Uint", 1, "Ptr", &outBuf, "UInt*", outLen, "ptr", 0, "ptr", 0 )

   return outLen
}

b2a_hex( ByRef pbData, dwLen )
{
	if (dwLen < 1)
		return 0
	if pbData is integer
		ptr := pbData
	else
		ptr := &pbData
	SetFormat,integer,Hex
	loop,%dwLen%
	{
		num := numget(ptr+0,A_index-1,"UChar")
		hash .= substr((num >> 4),0) . substr((num & 0xf),0)
	}
	SetFormat,integer,D
	StringLower,hash,hash
	return hash
}

a2b_hex( sHash,ByRef ByteBuf )
{
	if (sHash == "" || RegExMatch(sHash,"[^\dABCDEFabcdef]") || mod(StrLen(sHash),2))
		return 0
	BufLen := StrLen(sHash)/2
	VarSetCapacity(ByteBuf,BufLen,0)
	loop,%BufLen%
	{
		num1 := (p := "0x" . SubStr(sHash,(A_Index-1)*2+1,1)) << 4
		num2 := "0x" . SubStr(sHash,(A_Index-1)*2+2,1)
		num := num1 | num2
		NumPut(num,ByteBuf,A_Index-1,"UChar")
	}
	return BufLen
}

Free(byRef var)
{
  VarSetCapacity(var,0)
  return
}
